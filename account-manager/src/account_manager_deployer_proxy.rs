// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct AccountManagerDeployerProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for AccountManagerDeployerProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = AccountManagerDeployerProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        AccountManagerDeployerProxyMethods { wrapped_tx: tx }
    }
}

pub struct AccountManagerDeployerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> AccountManagerDeployerProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the contract with essential parameters and an optional admin address.
    ///
    /// # Arguments
    ///
    /// - `template` - the account manager template smart contract address
    /// - `controller` - the controller smart contract address
    /// - `opt_admin` - an optional admin address
    ///
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        template: Arg0,
        controller: Arg1,
        opt_admin: Arg2,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&template)
            .argument(&controller)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> AccountManagerDeployerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> AccountManagerDeployerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address.
    ///
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one.
    ///
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address.
    ///
    /// # Arguments:
    ///
    /// - `new_pending_admin` - The new pending admin address.
    ///
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint.
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// A utility function to highlight that this smart contract is an Account Manager Deployer.
    ///
    pub fn is_account_manager_deployer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isAccountManagerDeployer")
            .original_result()
    }

    pub fn is_managed_account<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isManagedAccount")
            .argument(&account)
            .original_result()
    }

    pub fn is_account_manager<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        manager: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isAccountManager")
            .argument(&manager)
            .original_result()
    }

    /// Updates the Account Manager smart contract template.
    ///
    /// # Arguments:
    ///
    /// - `template`: the Account Manager template smart contract address.
    ///
    pub fn update_account_manager_template<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        template: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAccountManagerTemplate")
            .argument(&template)
            .original_result()
    }

    /// Changes the owner of the Account Manager smart contract to the account being managed. This method can be called only
    /// once and will disable all the other interactions with the Account Manager smart contract from within this smart
    /// contract.
    ///
    pub fn change_account_manager_owner(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("changeAccountManagerOwner")
            .original_result()
    }

    /// Deploys an Account Manager smart contract for the caller, based on the current template.
    ///
    pub fn deploy_account_manager(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("deployAccountManager")
            .original_result()
    }

    pub fn mint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mint")
            .argument(&money_market)
            .original_result()
    }

    pub fn mint_and_enter_market<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mintAndEnterMarket")
            .argument(&money_market)
            .original_result()
    }

    pub fn stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        opt_account: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("stake")
            .argument(&provider)
            .argument(&opt_account)
            .original_result()
    }

    pub fn controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    pub fn template(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountManagerTemplate")
            .original_result()
    }

    pub fn account_manager<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        managed_account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountManager")
            .argument(&managed_account)
            .original_result()
    }

    pub fn managed_account<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account_manager: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getManagedAccount")
            .argument(&account_manager)
            .original_result()
    }
}
