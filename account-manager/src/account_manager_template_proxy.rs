// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct AccountManagerTemplateProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for AccountManagerTemplateProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = AccountManagerTemplateProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        AccountManagerTemplateProxyMethods { wrapped_tx: tx }
    }
}

pub struct AccountManagerTemplateProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> AccountManagerTemplateProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the contract with essential parameters.
    ///
    /// # Arguments
    ///
    /// - `managed_account` - the managed account address
    /// - `controller` - the controller smart contract address
    ///
    /// # Notes
    ///
    /// - The managed account is the account that will be able to perform actions on the contract.
    /// - The booster is set to the current observer set at the Controller level, and it cannot be updated.
    ///
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        managed_account: Arg0,
        controller: Arg1,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&managed_account)
            .argument(&controller)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> AccountManagerTemplateProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> AccountManagerTemplateProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Allows the managed account to withdraw funds from the contract.
    ///
    /// # Arguments
    ///
    /// - `token_id` - The token identifier.
    /// - `opt_amount` - The amount to withdraw. If not provided, the entire balance will be withdrawn.
    ///
    /// # Notes
    ///
    /// - The managed account can use this method to withdraw rewards if the admin has claimed rewards in his name at
    ///   Controller or Booster level.
    ///
    pub fn withdraw<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        token_id: Arg0,
        opt_amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdraw")
            .argument(&token_id)
            .argument(&opt_amount)
            .original_result()
    }

    pub fn is_account_manager(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isAccountManager")
            .original_result()
    }

    pub fn enter_markets<
        Arg0: ProxyArg<ManagedVec<Env::Api, EsdtTokenPayment<Env::Api>>>,
    >(
        self,
        payments: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("enterMarkets")
            .argument(&payments)
            .original_result()
    }

    pub fn exit_market<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        money_market: Arg0,
        opt_tokens: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("exitMarket")
            .argument(&money_market)
            .argument(&opt_tokens)
            .original_result()
    }

    pub fn exit_market_and_redeem<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<Option<BigUint<Env::Api>>>,
        Arg2: ProxyArg<Option<BigUint<Env::Api>>>,
    >(
        self,
        money_market: Arg0,
        opt_tokens: Arg1,
        opt_underlying_amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue3<EgldOrEsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("exitMarketAndRedeem")
            .argument(&money_market)
            .argument(&opt_tokens)
            .argument(&opt_underlying_amount)
            .original_result()
    }

    pub fn claim_rewards_controller<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<bool>,
        Arg3: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg4: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg5: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        boost: Arg0,
        supply: Arg1,
        borrow: Arg2,
        money_markets: Arg3,
        accounts: Arg4,
        opt_min_boosted_rewards_out: Arg5,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewardsController")
            .argument(&boost)
            .argument(&supply)
            .argument(&borrow)
            .argument(&money_markets)
            .argument(&accounts)
            .argument(&opt_min_boosted_rewards_out)
            .original_result()
    }

    pub fn claim_rewards_controller_tokens<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<bool>,
        Arg3: ProxyArg<ManagedVec<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
        Arg4: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg5: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg6: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        boost: Arg0,
        supply: Arg1,
        borrow: Arg2,
        tokens: Arg3,
        money_markets: Arg4,
        accounts: Arg5,
        opt_min_boosted_rewards_out: Arg6,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewardsControllerTokens")
            .argument(&boost)
            .argument(&supply)
            .argument(&borrow)
            .argument(&tokens)
            .argument(&money_markets)
            .argument(&accounts)
            .argument(&opt_min_boosted_rewards_out)
            .original_result()
    }

    pub fn mint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mint")
            .argument(&money_market)
            .original_result()
    }

    pub fn mint_and_enter_market<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mintAndEnterMarket")
            .argument(&money_market)
            .original_result()
    }

    pub fn redeem<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EsdtTokenPayment<Env::Api>>,
        Arg2: ProxyArg<Option<BigUint<Env::Api>>>,
    >(
        self,
        money_market: Arg0,
        token_payment_in: Arg1,
        opt_underlying_amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue2<EgldOrEsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("redeem")
            .argument(&money_market)
            .argument(&token_payment_in)
            .argument(&opt_underlying_amount)
            .original_result()
    }

    pub fn borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        underlying_amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrow")
            .argument(&money_market)
            .argument(&underlying_amount)
            .original_result()
    }

    pub fn repay_borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("repayBorrow")
            .argument(&money_market)
            .original_result()
    }

    pub fn stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        opt_account: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("stake")
            .argument(&provider)
            .argument(&opt_account)
            .original_result()
    }

    pub fn unstake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EsdtTokenPayment<Env::Api>>,
        Arg2: ProxyArg<PricingMethod>,
        Arg3: ProxyArg<OptionalValue<u64>>,
    >(
        self,
        provider: Arg0,
        payment: Arg1,
        pricing_method: Arg2,
        opt_max_cooldown_period: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unstake")
            .argument(&provider)
            .argument(&payment)
            .argument(&pricing_method)
            .argument(&opt_max_cooldown_period)
            .original_result()
    }

    pub fn claim<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        claim_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claim")
            .argument(&provider)
            .argument(&claim_id)
            .original_result()
    }

    pub fn stake_claim<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        from_provider: Arg0,
        claim_id: Arg1,
        to_provider: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("stakeClaim")
            .argument(&from_provider)
            .argument(&claim_id)
            .argument(&to_provider)
            .original_result()
    }

    pub fn claim_rewards_booster<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedVec<Env::Api, TokenIdentifier<Env::Api>>>,
        Arg3: ProxyArg<ManagedVec<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
        Arg4: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        boost: Arg0,
        provider: Arg1,
        pools: Arg2,
        reward_tokens_in: Arg3,
        opt_min_boosted_rewards_out: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewardsBooster")
            .argument(&boost)
            .argument(&provider)
            .argument(&pools)
            .argument(&reward_tokens_in)
            .argument(&opt_min_boosted_rewards_out)
            .original_result()
    }

    pub fn promote<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EsdtTokenPayment<Env::Api>>,
        Arg2: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        unstake_payment: Arg1,
        target_stake_token: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("promote")
            .argument(&provider)
            .argument(&unstake_payment)
            .argument(&target_stake_token)
            .original_result()
    }

    pub fn reallocate<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<EsdtTokenPayment<Env::Api>>,
    >(
        self,
        from_provider: Arg0,
        to_provider: Arg1,
        payment: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reallocate")
            .argument(&from_provider)
            .argument(&to_provider)
            .argument(&payment)
            .original_result()
    }

    pub fn managed_account(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getManagedAccount")
            .original_result()
    }

    pub fn controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    pub fn booster(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBooster")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Eq, Copy, Clone, Debug)]
pub enum PricingMethod {
    ReliablePrice,
    LastPrice,
}
