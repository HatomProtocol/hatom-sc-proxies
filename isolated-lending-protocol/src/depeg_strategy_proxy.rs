// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct DepegStrategyContractProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for DepegStrategyContractProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = DepegStrategyContractProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        DepegStrategyContractProxyMethods { wrapped_tx: tx }
    }
}

pub struct DepegStrategyContractProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> DepegStrategyContractProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the Depeg Strategy contract. 
    ///  
    /// # Arguments: 
    ///  
    /// - `egld_wrapper` - The wrapped EGLD smart contract for the pertinent shard. 
    /// - `ush_minter` - The USH minter contract address. 
    /// - `controller` - The Lending Protocol Controller's contract address. 
    /// - `opt_admin` - An optional admin address for the contract. 
    ///  
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        egld_wrapper: Arg0,
        ush_minter: Arg1,
        controller: Arg2,
        opt_admin: Arg3,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&egld_wrapper)
            .argument(&ush_minter)
            .argument(&controller)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> DepegStrategyContractProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> DepegStrategyContractProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address. 
    ///  
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one. 
    ///  
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_pending_admin` - The new pending admin address. 
    ///  
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint. 
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// Utility function to highlight that this smart contract is a Depeg Strategy. 
    ///  
    pub fn is_depeg_strategy(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isDepegStrategy")
            .original_result()
    }

    /// Checks whether the current state of the smart contract is active. 
    ///  
    pub fn is_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isActive")
            .original_result()
    }

    pub fn is_whitelisted_isolated_lending_protocol<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        sc_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isWhitelistedIsolatedLendingProtocol")
            .argument(&sc_address)
            .original_result()
    }

    /// Returns the Depeg Window delay. If unset, returns the default value. 
    ///  
    pub fn get_depeg_window_delay(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepegWindowDelay")
            .original_result()
    }

    /// Returns the Depeg Window duration. If unset, returns the default value. 
    ///  
    pub fn get_depeg_window_duration(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepegWindowDuration")
            .original_result()
    }

    /// Returns the Depeg Window status. If no window exists, returns Closed. 
    ///  
    pub fn get_depeg_window_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, DepegWindowStatus> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepegWindowStatus")
            .original_result()
    }

    /// Returns the Depeg Price Threshold. If unset, returns the default value. 
    ///  
    pub fn get_depeg_price_threshold(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepegPriceThreshold")
            .original_result()
    }

    /// Returns the Depeg Factor Model. If unset, returns the default values. 
    ///  
    pub fn get_depeg_factor_model(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, DepegFactorModel<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepegFactorModel")
            .original_result()
    }

    /// Returns the short term timestamp offset. If not set, returns the default value. 
    ///  
    pub fn get_short_term_offset(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getShortTermOffset")
            .original_result()
    }

    /// Returns the long term timestamp offset. If not set, returns the default value. 
    ///  
    pub fn get_long_term_offset(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLongTermOffset")
            .original_result()
    }

    /// Returns the instantaneous reserves of the xExchange Liquidity Pool. 
    ///  
    /// # Notes: 
    ///  
    /// - Returns the USH reserve first and the EGLD reserve second. 
    ///  
    pub fn get_instantaneous_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getInstantaneousReserves")
            .original_result()
    }

    /// Returns the average reserves of the xExchange Liquidity Pool over a given number of last rounds. 
    ///  
    /// # Arguments 
    ///  
    /// - `n_rounds` - The number of last rounds to consider for the average reserves. 
    ///  
    /// # Notes: 
    ///  
    /// - Returns the USH reserve first and the EGLD reserve second. 
    ///  
    pub fn get_last_average_reserves<
        Arg0: ProxyArg<u64>,
    >(
        self,
        n_rounds: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastAverageReserves")
            .argument(&n_rounds)
            .original_result()
    }

    /// Returns the total fee of the xExchange Liquidity Pool in basis points. 
    ///  
    pub fn get_pair_total_fee(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPairTotalFee")
            .original_result()
    }

    /// Returns the USH amount that can be obtained for a given EGLD amount by swapping at the xExchange Liquidity Pool. 
    ///  
    pub fn get_ush_amount_out<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        egld_amount_in: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshAmountOut")
            .argument(&egld_amount_in)
            .original_result()
    }

    /// Returns the USH amount already bought at the last swap block. 
    ///  
    pub fn get_last_swap_block_ush_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastSwapBlockUshAmount")
            .original_result()
    }

    /// Returns the EGLD amount already sold at the last swap block. 
    ///  
    pub fn get_last_swap_block_egld_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastSwapBlockEgldAmount")
            .original_result()
    }

    /// Returns the USH and EGLD amounts already swapped at the last swap block. 
    ///  
    pub fn get_last_swap_block_amounts(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastSwapBlockAmounts")
            .original_result()
    }

    /// Checks whether the Depeg Strategy can open a Depeg Window based on the current state of the smart contract, the 
    /// existence of a depeg, and the status of the Depeg Window. This method is used by redeemers to identify when they can 
    /// start the redemption process. 
    ///  
    pub fn can_open_depeg_window(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("canOpenDepegWindow")
            .original_result()
    }

    /// Checks whether USH has a depeg from USD based on the current state of the smart contract, the price of USH in USD, 
    /// and the status of the Depeg Window. Redemptions are allowed only when this method returns `true`. 
    ///  
    pub fn is_depegged(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isDepegged")
            .original_result()
    }

    /// Tries to open a Depeg Window. This method is used by redeemers to start the redemption process. 
    ///  
    pub fn open_depeg_window(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, DepegWindow> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("openDepegWindow")
            .original_result()
    }

    /// Checks whether USH is depegged from USD. 
    ///  
    pub fn has_depeg(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("hasDepeg")
            .original_result()
    }

    /// Returns the depeg factor that is needed so that redeemers and borrowers can share the rewards generated by the 
    /// redemption process. 
    ///  
    pub fn get_depeg_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepegFactor")
            .original_result()
    }

    /// Returns the maximum amount of USH that is allowed to be used for a redemption, given an EGLD amount. The limit is 
    /// given by the end price of USH in USD or the provided EGLD. 
    ///  
    /// # Arguments 
    ///  
    /// - `egld_amount_in` - The EGLD amount that is available for the redemption. 
    ///  
    pub fn get_max_ush_redeem_amount<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        egld_amount_in: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxUshRedeemAmount")
            .argument(&egld_amount_in)
            .original_result()
    }

    /// Swaps an Isolated Lending Protocol payment of EGLD for USH. 
    ///  
    /// # Notes: 
    ///  
    /// - can only be called by the Isolated Lending Protocol 
    /// - the Isolated Lending protocol calls this endpoint knowing that there is already a depeg 
    /// - the isolated lending protocol calls this endpoint with both a valid payment and a valid desired USH amount 
    ///  
    pub fn try_restore_peg<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ush_amount_out: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("tryRestorePeg")
            .argument(&ush_amount_out)
            .original_result()
    }

    /// Returns the minimum EGLD amount that is needed to restore the peg using either average or instantaneous reserves. 
    ///  
    pub fn get_egld_amount_for_peg(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldAmountForPeg")
            .original_result()
    }

    /// Returns the EGLD amount that is needed to restore the peg using instantaneous reserves. 
    ///  
    pub fn get_egld_amount_for_peg_instantaneous(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldAmountForPegInstantaneous")
            .original_result()
    }

    /// Returns the EGLD amount that is needed to restore the peg using average reserves. 
    ///  
    pub fn get_egld_amount_for_peg_average(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldAmountForPegAverage")
            .original_result()
    }

    /// Returns the EGLD amount from which a redemption would not generate profit. 
    ///  
    pub fn get_egld_amount_no_profit(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldAmountNoProfit")
            .original_result()
    }

    /// Returns the EGLD amount at which a redemption generates the maximum profit. 
    ///  
    pub fn get_egld_amount_max_profit(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldAmountMaxProfit")
            .original_result()
    }

    /// Activates the Depeg Strategy. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn activate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("activate")
            .original_result()
    }

    /// Deactivates the Depeg Strategy. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn deactivate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("deactivate")
            .original_result()
    }

    /// Whitelists an Isolated Lending Protocol. 
    ///  
    /// # Arguments 
    ///  
    /// - `isolated_lending_protocol` - The Isolated Lending Protocol address. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - the Isolated Lending Protocol must be a valid Isolated Lending Protocol 
    /// - the Isolated Lending Protocol must have the same USH token id as the one used by the Depeg Strategy 
    ///  
    pub fn whitelist_isolated_lending_protocol<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        isolated_lending_protocol: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("whitelistIsolatedLendingProtocol")
            .argument(&isolated_lending_protocol)
            .original_result()
    }

    /// Sets the round duration in milliseconds. 
    ///  
    /// # Arguments 
    ///  
    /// - `round_duration_ms` - The new round duration in milliseconds. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn set_round_duration<
        Arg0: ProxyArg<u64>,
    >(
        self,
        round_duration_ms: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRoundDuration")
            .argument(&round_duration_ms)
            .original_result()
    }

    /// Sets the depeg window delay. 
    ///  
    /// # Arguments 
    ///  
    /// - `depeg_window_delay` - The new depeg window delay in seconds. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn set_depeg_window_delay<
        Arg0: ProxyArg<u64>,
    >(
        self,
        depeg_window_delay: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDepegWindowDelay")
            .argument(&depeg_window_delay)
            .original_result()
    }

    /// Sets the depeg window duration. 
    ///  
    /// # Arguments 
    ///  
    /// - `depeg_window_duration` - The new depeg window duration in seconds. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn set_depeg_window_duration<
        Arg0: ProxyArg<u64>,
    >(
        self,
        depeg_window_duration: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDepegWindowDuration")
            .argument(&depeg_window_duration)
            .original_result()
    }

    /// Sets the short term and long term timestamp offsets for the xExchange Safe Price used to determine a depeg. 
    ///  
    /// # Arguments 
    ///  
    /// - `short_term_offset` - The new short term timestamp offset in seconds. 
    /// - `long_term_offset` - The new long term timestamp offset in seconds. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - there are minimum and maximum short term and long term timestamp offsets 
    /// - there is a minimum delta between the short term and long term timestamp offsets 
    ///  
    pub fn set_timestamp_offsets<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        short_term_offset: Arg0,
        long_term_offset: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setTimestampOffsets")
            .argument(&short_term_offset)
            .argument(&long_term_offset)
            .original_result()
    }

    /// Sets the Depeg Price Threshold, used to determine whether USH is depegged from USD or not. 
    ///  
    /// # Arguments 
    ///  
    /// - `price_threshold` - The new price threshold in USD with 18 decimals. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - there is a minimum and a maximum price threshold 
    /// - there is a default price threshold given by `DEFAULT_DEPEG_PRICE` 
    ///  
    pub fn set_depeg_price_threshold<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        price_threshold: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDepegPriceThreshold")
            .argument(&price_threshold)
            .original_result()
    }

    /// Sets the Depeg Factor Model parameters, used to determine how the rewards are shared between redeemers and borrowers. 
    ///  
    /// # Arguments 
    ///  
    /// - `redeemer_share` - The percentage of the rewards that goes to the redeemers in basis points. 
    /// - `min_price` - The price from which only the redeemers are rewarded, in USD with 18 decimals. 
    /// - `timestamp_offset` - The timestamp offset in seconds for the Safe Price. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - there is a default model 
    /// - a `min_price` of zero can be used to avoid sending all the rewards to the redeemers at a given price point 
    ///  
    pub fn set_depeg_factor_model_params<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        redeemer_share: Arg0,
        min_price: Arg1,
        timestamp_offset: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDepegFactorModelParams")
            .argument(&redeemer_share)
            .argument(&min_price)
            .argument(&timestamp_offset)
            .original_result()
    }

    /// Supports the xExchange WEGLD/USH Liquidity Pool and its Safe Price View Factory. 
    ///  
    /// # Arguments 
    ///  
    /// - `pair_address` - The xExchange WEGLD/USH Liquidity Pool address. 
    /// - `safe_price_factory` - The Safe Price View Factory address. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn support_xexchange_liquidity_pool<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pair_address: Arg0,
        safe_price_factory: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportXExchangeLiquidityPool")
            .argument(&pair_address)
            .argument(&safe_price_factory)
            .original_result()
    }

    /// Returns the price of USH in USD based on xExchange Liquidity Pool status. 
    ///  
    /// # Arguments 
    ///  
    /// - `timestamp_offset` - The time offset in seconds from the xExchange Liquidity Pool. 
    ///  
    pub fn get_ush_price_in_usd<
        Arg0: ProxyArg<u64>,
    >(
        self,
        timestamp_offset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshPriceInUsd")
            .argument(&timestamp_offset)
            .original_result()
    }

    /// Returns the price of EGLD in USD or USDC assuming that 1 USH == 1 USD or 1 USH == 1 USDC, depending on the USH 
    /// pricing mechanism at the Oracle. Notice that this method considers that USD has 18 decimals, which is consistent with 
    /// our Price Aggregator. 
    ///  
    pub fn get_egld_price_in_usd(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldPriceInUsd")
            .original_result()
    }

    /// Returns the Wrapped EGLD price in USH using the safe price mechanism with a given time offset from the xExchange 
    /// Liquidity Pool. 
    ///  
    /// # Arguments 
    ///  
    /// - `timestamp_offset` - The time offset in seconds from the xExchange Liquidity Pool. 
    ///  
    pub fn get_egld_price_in_ush<
        Arg0: ProxyArg<u64>,
    >(
        self,
        timestamp_offset: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldPriceInUsh")
            .argument(&timestamp_offset)
            .original_result()
    }

    /// Stores the smart contract state. 
    pub fn state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getState")
            .original_result()
    }

    /// Stores the Wrapped EGLD smart contract address. 
    pub fn egld_wrapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldWrapper")
            .original_result()
    }

    /// Stores the Wrapped EGLD token identifier. 
    pub fn wrapped_egld_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWrappedEgldTokenId")
            .original_result()
    }

    /// Stores the USH Minter smart contract address. 
    pub fn ush_minter(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshMinter")
            .original_result()
    }

    /// Stores the Controller smart contract address. 
    pub fn controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    /// Stores the USH token identifier. 
    pub fn ush_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshTokenId")
            .original_result()
    }

    pub fn isolated_lending_protocols(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getIsolatedLendingProtocols")
            .original_result()
    }

    /// Stores the Depeg Window. 
    pub fn depeg_window(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, DepegWindow> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepegWindow")
            .original_result()
    }

    /// Stores the round duration in milliseconds. 
    pub fn round_duration_ms(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRoundDurationMs")
            .original_result()
    }

    /// Stores the last block nonce where there was an intent to restore the peg. 
    pub fn last_swap_block_nonce(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastSwapBlockNonce")
            .original_result()
    }

    /// Stores the XExchange USH/WEGLD liquidity pool. 
    pub fn liquidity_pool(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, LiquidityPool<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidityPool")
            .original_result()
    }

    /// Stores the XExchange Safe Price View Factory address. 
    pub fn safe_price_factory(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSafePriceFactory")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq, Debug)]
pub enum DepegWindowStatus {
    Pending,
    Open,
    Closed,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Eq)]
pub struct DepegFactorModel<Api>
where
    Api: ManagedTypeApi,
{
    pub redeemer_share: u64,
    pub min_price: BigUint<Api>,
    pub timestamp_offset: u64,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq, Debug)]
pub enum State {
    Empty,
    Active,
    Inactive,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Eq)]
pub struct LiquidityPool<Api>
where
    Api: ManagedTypeApi,
{
    pub token0: TokenIdentifier<Api>,
    pub token1: TokenIdentifier<Api>,
    pub pair_address: ManagedAddress<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Eq)]
pub struct DepegWindow {
    pub init: u64,
    pub start: u64,
    pub end: u64,
}
