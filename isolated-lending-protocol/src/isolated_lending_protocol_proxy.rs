// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct IsolatedLendingProtocolProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for IsolatedLendingProtocolProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = IsolatedLendingProtocolProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        IsolatedLendingProtocolProxyMethods { wrapped_tx: tx }
    }
}

pub struct IsolatedLendingProtocolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> IsolatedLendingProtocolProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the contract. 
    ///  
    /// # Arguments: 
    ///  
    /// - `collateral_token_id` - The collateral token identifier. 
    /// - `min_collateral_amount` - The minimum collateral amount per account. 
    /// - `ush_minter` - The USH minter contract address. 
    /// - `ls_token_money_market` - The "collateral token Liquid Staked version" Money Market address. 
    /// - `liquid_staking` - The Liquid Staking contract address for the collateral token. 
    /// - `controller` - The Lending Protocol Controller's contract address. 
    /// - `opt_admin` - An optional admin address for the contract. 
    ///  
    pub fn init<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<ManagedAddress<Env::Api>>,
        Arg5: ProxyArg<ManagedAddress<Env::Api>>,
        Arg6: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        collateral_token_id: Arg0,
        min_collateral_amount: Arg1,
        ush_minter: Arg2,
        ls_token_money_market: Arg3,
        liquid_staking: Arg4,
        controller: Arg5,
        opt_admin: Arg6,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&collateral_token_id)
            .argument(&min_collateral_amount)
            .argument(&ush_minter)
            .argument(&ls_token_money_market)
            .argument(&liquid_staking)
            .argument(&controller)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> IsolatedLendingProtocolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> IsolatedLendingProtocolProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address. 
    ///  
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one. 
    ///  
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_pending_admin` - The new pending admin address. 
    ///  
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint. 
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// Utility function to highlight that this smart contract is a Isolated Lending Protocol. 
    ///  
    pub fn is_isolated_lending(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isIsolatedLending")
            .original_result()
    }

    /// Utility function used by other modules to check if they are calling the correct isolated lending protocol. 
    ///  
    pub fn is_isolated_lending_verified<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        collateral_token_id: Arg0,
        borrow_token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isIsolatedLendingVerified")
            .argument(&collateral_token_id)
            .argument(&borrow_token_id)
            .original_result()
    }

    /// Checks whether the current state of the smart contract is active. 
    ///  
    pub fn is_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isActive")
            .original_result()
    }

    /// Checks whether the current state of collateral is active. 
    ///  
    pub fn is_collateral_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isCollateralActive")
            .original_result()
    }

    /// Checks whether the current state of borrowing is active. 
    ///  
    pub fn is_borrow_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isBorrowActive")
            .original_result()
    }

    /// Checks whether the current state of redemptions is active. 
    ///  
    pub fn is_redeem_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isRedeemActive")
            .original_result()
    }

    /// Checks whether the current state of liquidations is active. 
    ///  
    pub fn is_liquidation_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isLiquidationActive")
            .original_result()
    }

    /// In one hand, it keeps the protocol members list updated. On the other hand, it inserts the account on the ordered 
    /// list or in the pending list, depending the conditions followed at `update_account_in_list_internal`. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account address. 
    ///  
    /// # Notes: 
    ///  
    /// - This function can be used in case `min_collateral_amount` and/or `min_borrow_amount` are changed, so accounts can 
    ///   be reevaluated, when the Redeem mode is set to `Tree`. 
    ///  
    pub fn update_account_data<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAccountData")
            .argument(&account)
            .original_result()
    }

    /// Updates the account membership in both the members list and the active members list. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account address. 
    ///  
    /// # Notes: 
    ///  
    /// - This function can be used in case `min_collateral_amount` and/or `min_borrow_amount` are changed, so accounts can 
    ///   be reevaluated, when the Redeem mode is set to `Random`. 
    ///  
    pub fn update_account_membership<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAccountMembership")
            .argument(&account)
            .original_result()
    }

    /// Inserts an account either on the ordered list or in the pending list, depending on the account's rate and the state 
    /// of the ordered list. If the ordered list is full, the account's rate is compared with the healthiest account's rate. 
    /// If the account's rate is higher, the healthiest account is moved to the pending list and the account is inserted into 
    /// the ordered list. Otherwise, the account is inserted into the pending list. On the other hand, if the ordered list is 
    /// not full, the account is inserted into the ordered list. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account address. 
    ///  
    /// # Notes: 
    ///  
    /// - This function can be used in case `min_collateral_amount` and/or `min_borrow_amount` are changed, so accounts can 
    ///   be reevaluated. 
    ///  
    pub fn update_account_in_list<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAccountInList")
            .argument(&account)
            .original_result()
    }

    /// Inserts a number of accounts from the pending list into the ordered list. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_n_insert` - An optional number of accounts to insert. If `None`, all accounts in the pending list will be 
    ///   inserted. 
    ///  
    /// # Notes: 
    ///  
    /// - This function is used to insert accounts from the pending list into the ordered list when the ordered list is not 
    ///   full. 
    ///  
    pub fn insert_pending_accounts<
        Arg0: ProxyArg<OptionalValue<usize>>,
    >(
        self,
        opt_n_insert: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("insertPendingAccounts")
            .argument(&opt_n_insert)
            .original_result()
    }

    /// Updates the collateral factor if possible and returns its updated value. 
    ///  
    pub fn update_and_get_collateral_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAndGetCollateralFactor")
            .original_result()
    }

    /// Returns the account with the highest rate in the tree, up to an optional threshold, if it exists. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_max_threshold` - An optional maximum threshold. If `None`, the account with the maximum rate is returned. If 
    ///   set, the account with the maximum rate below the threshold is returned. 
    ///  
    pub fn get_riskiest_account<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_max_rate: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRiskiestAccount")
            .argument(&opt_max_rate)
            .original_result()
    }

    /// Returns the account with the lowest rate in the tree. 
    ///  
    pub fn get_healthiest_account(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getHealthiestAccount")
            .original_result()
    }

    /// Returns the account tree rate. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account address. 
    ///  
    pub fn get_account_rate<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountRate")
            .argument(&account)
            .original_result()
    }

    pub fn get_ordered_list_size(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOrderedListSize")
            .original_result()
    }

    pub fn get_pending_list_size(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingListSize")
            .original_result()
    }

    /// Returns the collateral token price from the Oracle. 
    ///  
    pub fn get_collateral_token_price(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralTokenPrice")
            .original_result()
    }

    /// Returns the borrow token price (i.e. the USH token price) from the Oracle. 
    ///  
    pub fn get_borrow_token_price(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowTokenPrice")
            .original_result()
    }

    /// Returns the current number of victims that can be redeemed in a single redemption. If not set, it returns the 
    /// maximum. 
    ///  
    pub fn get_max_victims(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxVictims")
            .original_result()
    }

    /// Returns the current close factor. If not set, it returns the minimum allowed close factor. 
    ///  
    pub fn get_close_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCloseFactor")
            .original_result()
    }

    /// Returns the current liquidation incentive. If not set, it returns the minimum allowed liquidation incentive, which is 
    /// compliant with the default protocol seize share of 0% and the maximum collateral factor of 90%. 
    ///  
    pub fn get_liquidation_incentive(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationIncentive")
            .original_result()
    }

    /// Returns the current minimum borrow amount. If not set, it returns its default value. 
    ///  
    pub fn get_min_borrow_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMinBorrowAmount")
            .original_result()
    }

    /// Returns the maximum percent change of borrow during a random redeem. If not set, it returns its default value. 
    ///  
    pub fn get_random_redeem_ratio(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRandomRedeemRatio")
            .original_result()
    }

    /// Returns the number of users inspected in a Random Redeem. If not set, it returns its default value. 
    ///  
    pub fn get_max_candidates(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxCandidates")
            .original_result()
    }

    /// Activates the Isolated Lending Protocol. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn activate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("activate")
            .original_result()
    }

    /// Sets the collateral status. 
    ///  
    /// # Arguments: 
    ///  
    /// - `pause` - The new collateral status. `true` means paused, `false` means active. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_collateral_status<
        Arg0: ProxyArg<bool>,
    >(
        self,
        pause: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCollateralStatus")
            .argument(&pause)
            .original_result()
    }

    /// Sets the borrow status. 
    ///  
    /// # Arguments: 
    ///  
    /// - `pause` - The new borrow status. `true` means paused, `false` means active. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_borrow_status<
        Arg0: ProxyArg<bool>,
    >(
        self,
        pause: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBorrowStatus")
            .argument(&pause)
            .original_result()
    }

    /// Sets the redeem status. 
    ///  
    /// # Arguments: 
    ///  
    /// - `pause` - The new redeem status. `true` means paused, `false` means active. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_redeem_status<
        Arg0: ProxyArg<bool>,
    >(
        self,
        pause: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRedeemStatus")
            .argument(&pause)
            .original_result()
    }

    /// Sets the liquidation status. 
    ///  
    /// # Arguments: 
    ///  
    /// - `pause` - The new liquidation status. `true` means paused, `false` means active. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_liquidation_status<
        Arg0: ProxyArg<bool>,
    >(
        self,
        pause: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidationStatus")
            .argument(&pause)
            .original_result()
    }

    /// Updates the minimum collateral amount required per account. This value is also considered when adding accounts to the 
    /// ordered list. 
    ///  
    /// # Arguments 
    ///  
    /// - `min_collateral_amount` - The new minimum collateral amount. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - the new minimum collateral amount must be greater than the minimum allowed 
    ///  
    pub fn set_min_collateral_amount<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        min_collateral_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMinCollateralAmount")
            .argument(&min_collateral_amount)
            .original_result()
    }

    /// Updates the minimum borrow amount per account, which is the minimum amount of USH that is considered when inserting 
    /// an account into the ordered list. Notice this is not the minimum amount that can be borrowed by an account. 
    ///  
    /// # Arguments 
    ///  
    /// - `min_borrow_amount` - The new minimum collateral amount. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - the new minimum borrow amount must be greater than the minimum allowed 
    ///  
    pub fn set_min_borrow_amount<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        min_borrow_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMinBorrowAmount")
            .argument(&min_borrow_amount)
            .original_result()
    }

    /// Updates the Depeg Strategy smart contract address. 
    ///  
    /// # Arguments 
    ///  
    /// - `depeg_strategy` - The Depeg Strategy smart contract address. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - the provided address must be valid a Depeg Strategy smart contract 
    /// - there is no need for the Depeg Strategy to be active 
    ///  
    pub fn set_depeg_strategy<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        depeg_strategy: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDepegStrategy")
            .argument(&depeg_strategy)
            .original_result()
    }

    /// Updates the collateral cap. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_collateral_cap` - The collateral cap. `None` means no cap. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_collateral_cap<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_collateral_cap: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCollateralCap")
            .argument(&opt_collateral_cap)
            .original_result()
    }

    /// Updates the borrow cap. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_borrow_cap` - The borrow cap. `None` means no cap. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_borrow_cap<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_borrow_cap: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBorrowCap")
            .argument(&opt_borrow_cap)
            .original_result()
    }

    /// Updates the Staking smart contract address. 
    ///  
    /// # Arguments: 
    ///  
    /// - `staking_sc` - The Staking smart contract address. 
    ///  
    pub fn set_staking_contract<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        staking_sc: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStakingContract")
            .argument(&staking_sc)
            .original_result()
    }

    /// Sets the maximum number of victims that can be redeemed in a single redemption. 
    ///  
    /// # Arguments: 
    ///  
    /// - `max_victims` - The new maximum number of victims. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_max_victims<
        Arg0: ProxyArg<usize>,
    >(
        self,
        max_victims: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxVictims")
            .argument(&max_victims)
            .original_result()
    }

    /// Sets the collateral factor or loan to value. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_collateral_factor` - The new collateral factor in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The new collateral factor must not exceed the maximum allowed. 
    /// - The new collateral factor cannot be lower than the previous one by more than the maximum allowed decrease. 
    ///  
    pub fn set_collateral_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        new_collateral_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCollateralFactor")
            .argument(&new_collateral_factor)
            .original_result()
    }

    /// Sets the close factor used at liquidations. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_close_factor` - The new close factor in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_close_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        close_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCloseFactor")
            .argument(&close_factor)
            .original_result()
    }

    /// Updates the liquidation incentive for liquidations. 
    ///  
    /// # Arguments 
    ///  
    /// - `liquidation_incentive` - The new liquidation incentive in wad. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - the new liquidation incentive should not be less than the amount that would yield losses for liquidators 
    /// - the new liquidation incentive should be less than `1 / eff_ltv`, which is conservatively assumed to be `1 / 
    ///   max_ltv`. Otherwise, there won't be a Risky region. 
    ///  
    pub fn set_liquidation_incentive<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        liquidation_incentive: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidationIncentive")
            .argument(&liquidation_incentive)
            .original_result()
    }

    /// Updates the protocol seize share, i.e. the portion of the seized amount that is kept by the protocol. 
    ///  
    /// # Arguments 
    ///  
    /// - `protocol_seize_share` - The new protocol seize share in wad. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - the new protocol seize share cannot exceed the amount that would yield losses for liquidators 
    ///  
    pub fn set_protocol_seize_share<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        protocol_seize_share: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setProtocolSeizeShare")
            .argument(&protocol_seize_share)
            .original_result()
    }

    /// Updates the stake factor, i.e. the portion of the reserves that is used as staking rewards. 
    ///  
    /// # Arguments: 
    ///  
    /// - `stake_factor` - The new reserve factor in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The new stake factor must not exceed the maximum allowed. 
    ///  
    pub fn set_stake_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        stake_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStakeFactor")
            .argument(&stake_factor)
            .original_result()
    }

    /// Withdraws an specified amount of Hatom's staked tokens from the reserves (revenue part) to the admin account. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_h_ls_token_amount` - The amount of Hatom's staked tokens to withdraw. If not provided, the entire revenue is 
    ///   withdrawn. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn reduce_reserves<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_delta_revenue: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reduceReserves")
            .argument(&opt_delta_revenue)
            .original_result()
    }

    /// Starts the migration process from `Tree` redeem mode to `Random` redeem mode. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The current redeem mode must be `Tree`. 
    /// - The `Random` redeem mode must not be pending. 
    /// - This interaction can be reverted by calling `unset_pending_random_redeem_mode`. 
    ///  
    pub fn set_pending_random_redeem_mode(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingRandomRedeemMode")
            .original_result()
    }

    /// Unset the pending `Random` redeem mode. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The `Random` redeem mode must be pending. 
    /// - This interaction reverts the `set_pending_random_redeem_mode` interaction. 
    ///  
    pub fn unset_pending_random_redeem_mode(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unsetPendingRandomRedeemMode")
            .original_result()
    }

    /// Confirms the migration process from `Tree` redeem mode to `Random` redeem mode. This interaction is the final step 
    /// in the migration process and cannot be reverted. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The `Random` redeem mode must be pending. 
    /// - This interaction finalizes the migration process. 
    /// - This interaction cannot be reverted. 
    ///  
    pub fn accept_random_redeem_mode(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptRandomRedeemMode")
            .original_result()
    }

    /// Sets the borrow ratio used at random redeem, i.e. the maximum percentage of a user borrow that can be redeemed during 
    /// a random redeem. 
    ///  
    /// # Arguments: 
    ///  
    /// - `ratio` - The new random redeem ratio in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_random_redeem_ratio<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ratio: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRandomRedeemRatio")
            .argument(&ratio)
            .original_result()
    }

    /// Sets the amount of candidates analyzed during a random redeem. 
    ///  
    /// # Arguments: 
    ///  
    /// - `max_candidates` - The amount of candidates. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_max_candidates<
        Arg0: ProxyArg<usize>,
    >(
        self,
        max_candidates: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxCandidates")
            .argument(&max_candidates)
            .original_result()
    }

    /// Allows users to add collateral to their positions. 
    ///  
    /// # Notes: 
    ///  
    /// - A user can pay with collateral token (e.g. EGLD), staked token (e.g. sEGLD) or Hatom's staked token (e.g. HsEGLD). 
    /// - All payments are converted into Hatom's staked tokens but registered in the user's position as collateral token. 
    /// - If the user enters with collateral token, he might get accredited a slightly different amount than what he sent. 
    ///   This means that a payment of exactly `min_collateral_amount` might fail. 
    /// - Returns the equivalent amount of token that was accredited to the user. 
    ///  
    pub fn add_collateral(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .raw_call("addCollateral")
            .original_result()
    }

    /// Repays an outstanding USH borrow. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_borrower` - An optional borrower address. Otherwise, caller is assumed to be the borrower. 
    ///  
    /// Notes: 
    ///  
    /// - The repayment amount can be higher than the outstanding borrow. In such case, the remainder is returned. 
    ///  
    pub fn repay_borrow<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_borrower: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("repayBorrow")
            .argument(&opt_borrower)
            .original_result()
    }

    /// Liquidates borrower through a borrow repayment and collateral seizure. 
    ///  
    /// # Arguments: 
    ///  
    /// - `borrower` - The account to be liquidated. 
    /// - `opt_min_tokens` - The minimum amount of tokens to be seized from the borrower. 
    ///  
    pub fn liquidate_borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        borrower: Arg0,
        opt_min_tokens: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("liquidateBorrow")
            .argument(&borrower)
            .argument(&opt_min_tokens)
            .original_result()
    }

    /// Allows users to remove collateral from the protocol. 
    ///  
    /// # Arguments: 
    ///  
    /// - `collateral_type` - The type of collateral to withdraw. 
    /// - `opt_collateral_out` - An optional amount of collateral to withdraw. If not provided, the user will withdraw all of 
    ///   his collateral. 
    ///  
    /// # Notes: 
    ///  
    /// - For EGLD ILP, the user is paid back on staked token (e.g. sEGLD), Hatom's staked token (e.g. HsEGLD) or the 
    ///   undelegate NFT. 
    /// - For wTAO ILP, the user is paid back on the staked token (e.g. swTAO), Hatom's staked token (e.g. HswTAO) or in 
    ///   wTAO. 
    /// - The user can withdraw all of his collateral or a part of it, but at least `min_collateral_amount` must remain in 
    ///   the protocol. 
    /// - The user must remain solvent after the withdrawal. 
    ///  
    pub fn remove_collateral<
        Arg0: ProxyArg<CollateralType>,
        Arg1: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        collateral_type: Arg0,
        opt_collateral_out: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeCollateral")
            .argument(&collateral_type)
            .argument(&opt_collateral_out)
            .original_result()
    }

    /// Allows a user to borrow USH from the protocol. 
    ///  
    /// # Arguments: 
    ///  
    /// - `ush_amount` - The amount of USH to borrow. 
    ///  
    /// # Notes: 
    ///  
    /// - The user must have enough collateral to borrow. 
    /// - The user must remain solvent after the borrow. 
    ///  
    pub fn borrow<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ush_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrow")
            .argument(&ush_amount)
            .original_result()
    }

    /// Redeems USH borrows when there is a depeg. The redemption mechanism is a public process that allows anyone to repay 
    /// the riskiest USH borrows in exchange of collateral. This process can be profitable for the redeemer given that USH is 
    /// trading on the open market below the pegged price while the protocol assumes a pegged price. The redeemer provides 
    /// funding in the form of EGLD, which is swapped for USH through the respective pool, helping restore the USH peg to the 
    /// dollar in the pool. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_min_amount_out` - An optional minimum amount out of seized collateral. 
    /// - `opt_gas_deletion` - An optional amount of gas required for each deletion. 
    /// - `opt_gas_insertion` - An optional amount of gas required for each insertion. 
    ///  
    pub fn redeem<
        Arg0: ProxyArg<Option<BigUint<Env::Api>>>,
        Arg1: ProxyArg<Option<u64>>,
        Arg2: ProxyArg<Option<u64>>,
    >(
        self,
        opt_min_amount_out: Arg0,
        opt_gas_deletion: Arg1,
        opt_gas_insertion: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue4<EsdtTokenPayment<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("redeem")
            .argument(&opt_min_amount_out)
            .argument(&opt_gas_deletion)
            .argument(&opt_gas_insertion)
            .original_result()
    }

    /// Accrues reserves by taking into consideration updated exchange rates. 
    ///  
    pub fn accrue_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("accrueReserves")
            .original_result()
    }

    /// Checks if an account is currently eligible for liquidations. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account to check. 
    ///  
    pub fn is_risky<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isRisky")
            .argument(&account)
            .original_result()
    }

    /// Simulates the risk profile of an account based on the current collateral and borrow amounts and a simulated 
    /// withdrawal of collateral or a borrow. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account for which to simulate the risk profile. 
    /// - `collateral_out` - The simulated amount of collateral to withdraw. 
    /// - `borrow_amount` - The simulated amount of borrow to take. 
    ///  
    pub fn simulate_risk_profile<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        account: Arg0,
        collateral_out: Arg1,
        borrow_amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, RiskProfile<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("simulateRiskProfile")
            .argument(&account)
            .argument(&collateral_out)
            .argument(&borrow_amount)
            .original_result()
    }

    /// Claims staking rewards from the staking contract. 
    ///  
    pub fn claim_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimStakingRewards")
            .original_result()
    }

    /// Stores the smart contract state. 
    pub fn state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getState")
            .original_result()
    }

    /// Stores the collateral status. 
    pub fn collateral_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralStatus")
            .original_result()
    }

    /// Stores the borrow status. 
    pub fn borrow_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowStatus")
            .original_result()
    }

    /// Stores the redeem status. 
    pub fn redeem_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRedeemStatus")
            .original_result()
    }

    /// Stores the liquidation status. 
    pub fn liquidation_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationStatus")
            .original_result()
    }

    /// Stores the collateral token identifier. 
    pub fn collateral_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralTokenId")
            .original_result()
    }

    /// Stores the minimum collateral amount in collateral tokens. 
    pub fn min_collateral_amount(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMinCollateralAmount")
            .original_result()
    }

    /// Stores the liquid staked token Money Market smart contract address. 
    pub fn ls_token_money_market(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLsTokenMoneyMarket")
            .original_result()
    }

    /// Stores the Liquid Staking smart contract address. 
    pub fn liquid_staking(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidStaking")
            .original_result()
    }

    /// Stores the USH Minter smart contract address. 
    pub fn ush_minter(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshMinter")
            .original_result()
    }

    /// Stores the Controller smart contract address. 
    pub fn controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    /// The liquid staked token identifier. 
    pub fn ls_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLsTokenId")
            .original_result()
    }

    /// The Lending Protocol Hatom's staked token identifier. 
    pub fn h_ls_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getHLsTokenId")
            .original_result()
    }

    pub fn ush_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshTokenId")
            .original_result()
    }

    /// Stores the collateral cap in collateral tokens. 
    pub fn collateral_cap(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralCap")
            .original_result()
    }

    /// Stores the total collateral amount in collateral token. 
    pub fn total_collateral(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalCollateral")
            .original_result()
    }

    /// Stores the account collateral in collateral token. 
    pub fn account_collateral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountCollateral")
            .argument(&account)
            .original_result()
    }

    /// Stores the borrow cap in USH. 
    pub fn borrow_cap(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowCap")
            .original_result()
    }

    /// Stores the total amount of outstanding USH borrows. 
    pub fn total_borrows(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalBorrows")
            .original_result()
    }

    /// Stores the account USH borrow. 
    pub fn account_borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        borrower: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountBorrow")
            .argument(&borrower)
            .original_result()
    }

    /// Stores the total amount of Hatom's staked tokens deposited in the protocol. 
    pub fn total_h_ls_tokens(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalHLsTokens")
            .original_result()
    }

    /// Stores the current amount of reserves in Hatom's staked tokens. 
    pub fn total_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalReserves")
            .original_result()
    }

    /// Stores the total amount of staking rewards in Hatom's staked tokens. 
    pub fn staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingRewards")
            .original_result()
    }

    /// Stores the amount of protocol revenue in Hatom's staked tokens. 
    pub fn revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRevenue")
            .original_result()
    }

    /// Stores the current collateral factor. 
    pub fn collateral_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralFactor")
            .original_result()
    }

    /// Stores the next collateral factor. 
    pub fn next_collateral_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNextCollateralFactor")
            .original_result()
    }

    /// Stores the current protocol seize share. 
    pub fn protocol_seize_share(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getProtocolSeizeShare")
            .original_result()
    }

    /// Stores the Depeg Strategy smart contract address. 
    pub fn depeg_strategy(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDepegStrategy")
            .original_result()
    }

    /// Stores the Staking Module smart contract address. 
    pub fn staking_sc(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingSc")
            .original_result()
    }

    /// Stores the current stake factor. 
    pub fn stake_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakeFactor")
            .original_result()
    }

    /// Stores the redeem mode. 
    pub fn redeem_mode(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, RedeemMode> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRedeemMode")
            .original_result()
    }

    /// Stores whether the random redeem mode is pending or not. 
    pub fn is_random_redeem_mode_pending(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isRandomRedeemModePending")
            .original_result()
    }

    /// Stores the accounts pending to be added to the ordered list. 
    pub fn pending_list(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingList")
            .original_result()
    }

    /// Stores the set of addresses that belong the protocol. 
    pub fn members(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMembers")
            .original_result()
    }

    /// Stores the set of active members. 
    pub fn active_members(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getActiveMembers")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq)]
pub enum State {
    Empty,
    Active,
    Inactive,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq)]
pub enum Status {
    Empty,
    Active,
    Paused,
}

#[type_abi]
#[derive(TopDecode)]
pub enum CollateralType {
    HLSToken,
    LSToken,
    Token,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Clone, Debug)]
pub enum RiskProfile<Api>
where
    Api: ManagedTypeApi,
{
    Solvent(BigUint<Api>),
    RiskyOrInsolvent(BigUint<Api>),
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq)]
pub enum RedeemMode {
    Tree,
    Random,
}
