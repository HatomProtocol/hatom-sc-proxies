// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct ControllerProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for ControllerProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = ControllerProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        ControllerProxyMethods { wrapped_tx: tx }
    }
}

pub struct ControllerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> ControllerProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the contract with an optional admin address.
    ///
    /// # Arguments:
    ///
    /// - `opt_admin` - An optional admin address for the contract.
    ///
    /// Notes:
    ///
    /// - If the contract is being deployed for the first time, the admin address will be set.
    /// - If the admin address is not provided, the admin will be set as the deployer.
    /// - If the contract is being upgraded, the admin address will not be overwritten.
    ///
    pub fn init<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_admin: Arg0,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> ControllerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> ControllerProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address.
    ///
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one.
    ///
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address.
    ///
    /// # Arguments:
    ///
    /// - `new_pending_admin` - The new pending admin address.
    ///
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint.
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// Incorporates a money market in a list of accepted money markets (a whitelist). This action will add support for the
    /// provided money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provided address must be a valid money market smart contract.
    /// - The money market should not has already been supported in the past.
    ///
    pub fn support_market<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportMarket")
            .argument(&money_market)
            .original_result()
    }

    /// Sets the maximum number of money markets that can be entered per account.
    ///
    /// # Arguments:
    ///
    /// - `new_max_markets_per_account` - The new maximum number of money markets that can be entered per account.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - Must be higher than the current maximum.
    ///
    pub fn set_max_markets_per_account<
        Arg0: ProxyArg<usize>,
    >(
        self,
        new_max_markets_per_account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxMarketsPerAccount")
            .argument(&new_max_markets_per_account)
            .original_result()
    }

    /// Sets the collateral factors or loan to values for a given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `new_cf` - The new collateral factor in wad.
    /// - `new_uf` - The new USH borrower collateral factor in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provided market must be a whitelisted money market.
    /// - The new collateral factors must not exceed their maximum allowed.
    /// - The new collateral factor cannot be lower than the previous one by more than the maximum allowed decrease.
    /// - The USH borrower collateral factor cannot exceed the collateral factor at any time.
    /// - A collateral factor of zero should be configured when a market is deprecated.
    ///
    pub fn set_collateral_factors<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        new_cf: Arg1,
        new_uf: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCollateralFactors")
            .argument(&money_market)
            .argument(&new_cf)
            .argument(&new_uf)
            .original_result()
    }

    /// Sets the pricing Oracle smart contract address.
    ///
    /// # Arguments:
    ///
    /// - `new_price_oracle` - The address of the pricing oracle smart contract.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provided address must be a valid oracle smart contract.
    ///
    pub fn set_price_oracle<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_price_oracle: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPriceOracle")
            .argument(&new_price_oracle)
            .original_result()
    }

    /// Sets a liquidity cap for a given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `new_liquidity_cap` - The new liquidity cap in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provided address must be a whitelisted money market.
    ///
    pub fn set_liquidity_cap<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        new_liquidity_cap: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidityCap")
            .argument(&money_market)
            .argument(&new_liquidity_cap)
            .original_result()
    }

    /// Sets a borrow cap for a given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `new_borrow_cap` - The new borrow cap in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provided address must be a whitelisted money market.
    ///
    pub fn set_borrow_cap<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        new_borrow_cap: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBorrowCap")
            .argument(&money_market)
            .argument(&new_borrow_cap)
            .original_result()
    }

    /// Sets the maximum amount of rewards batches per money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `new_max_rewards_batches` - The new maximum amount of rewards batches.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provided address must be a whitelisted money market.
    ///
    pub fn set_max_rewards_batches<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        money_market: Arg0,
        new_max_rewards_batches: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxRewardsBatches")
            .argument(&money_market)
            .argument(&new_max_rewards_batches)
            .original_result()
    }

    /// Sets the maximum slippage allowed for configuration swaps.
    ///
    /// # Arguments:
    ///
    /// - `new_max_slippage` - The new maximum slippage allowed.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_max_slippage<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        new_max_slippage: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxSlippage")
            .argument(&new_max_slippage)
            .original_result()
    }

    /// Adds a rewards batch to the specified money market. EGLD or ESDT tokens are supported.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `market_type` - Distribute rewards for suppliers (`Supply`) or lenders (`Borrows`).
    /// - `period` - The period of time in seconds in which rewards are distributed.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - The provided address must be whitelisted money market.
    /// - Should be paid with the rewards token.
    ///
    pub fn set_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<MarketType>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        money_market: Arg0,
        market_type: Arg1,
        period: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, usize> {
        self.wrapped_tx
            .raw_call("setRewardsBatch")
            .argument(&money_market)
            .argument(&market_type)
            .argument(&period)
            .original_result()
    }

    /// Adds an amount of reward token to an existing rewards batch maintaining the same speed.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `batch_id` - the rewards batch identifier
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn add_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addRewardsBatch")
            .argument(&money_market)
            .argument(&batch_id)
            .original_result()
    }

    /// Cancel a specified rewards batch. Remaining tokens are sent back to a beneficiary.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - the address of the money market smart contract.
    /// - `batch_id` - the rewards batch identifier
    /// - `opt_to` - the beneficiary address for the remaining tokens (optional)
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - The caller is selected if no beneficiary is given.
    ///
    pub fn cancel_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        opt_to: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelRewardsBatch")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&opt_to)
            .original_result()
    }

    /// Removes a specified rewards batch from the array of rewards batches iff it has been fully distributed.
    ///
    /// # Arguments
    ///
    /// - `money_market` - the address of the money market smart contract.
    /// - `batch_id` - the rewards batch identifier
    ///
    /// # Notes
    ///
    /// - can be called by anyone
    /// - takes into consideration possible rounding errors but it is conservative
    ///
    pub fn remove_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeRewardsBatch")
            .argument(&money_market)
            .argument(&batch_id)
            .original_result()
    }

    /// Removes a specified rewards batch from the array of rewards batches iff it has been fully distributed within a given
    /// tolerance amount.
    ///
    /// # Arguments
    ///
    /// - `money_market` - the address of the money market smart contract.
    /// - `batch_id` - the rewards batch identifier
    /// - `tolerance` - the tolerance in wad, such that 1 wad = 100%.
    ///
    /// # Notes
    ///
    /// - can only be called by the admin or rewards manager.
    ///
    pub fn admin_remove_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        tolerance: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("adminRemoveRewardsBatch")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&tolerance)
            .original_result()
    }

    /// Updates a given rewards batch based on a new speed. The new speed of rewards also changes the remaining distribution
    /// time period.
    ///
    ///
    /// # Arguments:
    ///
    /// - `money_market` - the address of the money market smart contract.
    /// - `batch_id` - The rewards batch identifier.
    /// - `new_speed` - The new speed of rewards in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn update_rewards_batch_speed<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        new_speed: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRewardsBatchSpeed")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&new_speed)
            .original_result()
    }

    /// Updates a given rewards batch based on a new period. The new period also changes the speed of rewards.
    ///
    ///
    /// # Arguments:
    ///
    /// - `money_market` - the address of the money market smart contract.
    /// - `batch_id` - The rewards batch identifier.
    /// - `new_dt` - The new period.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn update_rewards_batch_remaining_period<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        new_dt: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRewardsBatchRemainingPeriod")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&new_dt)
            .original_result()
    }

    /// Claims the undistributed rewards for a given rewards token.
    ///
    /// # Arguments:
    ///
    /// - `rewards_token_id` - the rewards token identifier
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The rewards token must have undistributed rewards.
    /// - Undistributed rewards might originate at markets without collateral or borrows, or because of truncation errors.
    ///
    pub fn claim_undistributed_rewards<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        rewards_token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimUndistributedRewards")
            .argument(&rewards_token_id)
            .original_result()
    }

    /// Adds support for boosting rewards batches by converting the rewards batch tokens into Hatom's governance tokens with
    /// a premium.
    ///
    /// # Arguments:
    ///
    /// - `governance_token_id` - the governance token identifier
    /// - `egld_wrapper` - the address of the EGLD wrapper smart contract
    /// - `router` - the address of the router smart contract
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn support_rewards_batch_boosting<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        governance_token_id: Arg0,
        egld_wrapper: Arg1,
        router: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportRewardsBatchBoosting")
            .argument(&governance_token_id)
            .argument(&egld_wrapper)
            .argument(&router)
            .original_result()
    }

    /// Enables support for boosting rewards batches.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn enable_rewards_batch_boosting(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("enableRewardsBatchBoosting")
            .original_result()
    }

    /// Disables support for boosting rewards batches.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn disable_rewards_batch_boosting(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("disableRewardsBatchBoosting")
            .original_result()
    }

    /// Boosts the rewards of a given rewards token by converting the rewards tokens into Hatom's governance token with a
    /// premium.
    ///
    /// # Arguments:
    ///
    /// - `premium` - the premium in wad, such that 1 wad = 100%.
    /// - `fwd_swap_amount` - the amount of tokens to swap.
    /// - `fwd_swap_path` - the swap path to convert the rewards batch tokens into Hatom's governance tokens.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - If rewards token is EGLD, swaps will add a EGLD => WEGLD step first. Also, the swap path needs to use the WEGLD
    ///   token identifier.
    ///
    pub fn boost_rewards<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedVec<Env::Api, SwapStep<Env::Api>>>,
    >(
        self,
        premium: Arg0,
        fwd_swap_amount: Arg1,
        fwd_swap_path: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("boostRewards")
            .argument(&premium)
            .argument(&fwd_swap_amount)
            .argument(&fwd_swap_path)
            .original_result()
    }

    /// Updates the premium of a given booster and, if a payment is provided, adds it to the booster's amount.
    ///
    /// # Arguments:
    ///
    /// - `rewards_token_id` - the rewards token identifier for which we wish to update its booster.
    /// - `premium` - the premium in wad, such that 1 wad = 100%.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - Cannot change the swap path. That requires canceling the booster and creating a new one.
    ///
    pub fn update_booster<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        rewards_token_id: Arg0,
        premium: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("updateBooster")
            .argument(&rewards_token_id)
            .argument(&premium)
            .original_result()
    }

    /// Cancels a given booster and sends the remaining tokens back to the caller.
    ///
    /// # Arguments:
    ///
    /// - `rewards_token_id` - the rewards token identifier for which we wish to cancel its booster.
    /// - `opt_to` - the beneficiary address for the remaining tokens (optional).
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn cancel_booster<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        rewards_token_id: Arg0,
        opt_to: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelBooster")
            .argument(&rewards_token_id)
            .argument(&opt_to)
            .original_result()
    }

    /// Updates the collateral or account tokens of a given account in a given money market, which is useful at liquidations.
    /// The general idea is that the account is removing collateral, which should update the total collateral tokens and the
    /// account's collateral tokens.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `account` - The address of the account we wish to update.
    /// - `tokens` - The number of Hatom's tokens to set as collateral.
    ///
    /// # Notes:
    ///
    /// - Can only be called by a whitelisted money market.
    /// - The provided address must be a whitelisted money market.
    /// - Makes sure the mappers `account_markets` and `market_members` remain updated.
    ///
    pub fn set_account_collateral_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        account: Arg1,
        new_tokens: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAccountTokens")
            .argument(&money_market)
            .argument(&account)
            .argument(&new_tokens)
            .original_result()
    }

    /// Sets the Rewards Manager of the protocol.
    ///
    /// # Arguments:
    ///
    /// - `new_rewards_manager` - The address of the new Rewards Manager.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_rewards_manager<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_rewards_manager: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRewardsManager")
            .argument(&new_rewards_manager)
            .original_result()
    }

    /// Sets the Guardian of the protocol.
    ///
    /// # Arguments:
    ///
    /// - `new_pause_guardian` - The address of the new Guardian.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_pause_guardian<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_pause_guardian: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPauseGuardian")
            .argument(&new_pause_guardian)
            .original_result()
    }

    /// Sets a Rewards Booster smart contract as an observer, i.e. as a contract that is notified when accounts deposit or
    /// withdraw collateral from markets. The name Booster Observer is used to reference the Rewards Booster smart contract.
    ///
    /// # Arguments:
    ///
    /// - `new_booster_observer` - the rewards booster smart contract address.
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - `new_booster_observer` must be a rewards booster smart contract
    /// - `new_booster_observer` must not have been already used as a rewards booster
    ///
    pub fn set_booster_observer<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_booster_observer: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBoosterObserver")
            .argument(&new_booster_observer)
            .original_result()
    }

    /// Removes Rewards Booster smart contract from being an observer. From this point onwards, this smart contract will not
    /// be notified of any market change.
    ///
    pub fn clear_booster_observer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("clearBoosterObserver")
            .original_result()
    }

    /// Sets a USH Money Market smart contract as an observer, i.e. as a contract that is notified when accounts deposit or
    /// withdraw collateral from markets. The name USH Market Observer is used to reference the USH Money Market smart
    /// contract.
    ///
    /// # Arguments:
    ///
    /// - `new_ush_market_observer` - The USH Money Market smart contract address.
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - `new_ush_market_observer` must have been already whitelisted as a money market
    /// - `new_ush_market_observer` must not have been already used as a USH market observer
    ///
    pub fn set_ush_market_observer<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_ush_market_observer: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setUshMarketObserver")
            .argument(&new_ush_market_observer)
            .original_result()
    }

    /// Clears the USH Market smart contract from being an observer. From this point onwards, this smart contract will not be
    /// notified of any market change.
    ///
    pub fn clear_ush_market_observer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("clearUshMarketObserver")
            .original_result()
    }

    /// Changes the minting status for a specific money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `pause` - A boolean that indicates whether the protocol must be or not paused.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or the Guardian.
    ///
    pub fn pause_mint<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<bool>,
    >(
        self,
        money_market: Arg0,
        pause: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pauseMint")
            .argument(&money_market)
            .argument(&pause)
            .original_result()
    }

    /// Changes the borrowing status for a specific money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `pause` - A boolean that indicates whether the protocol must be or not paused.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or the Guardian.
    ///
    pub fn pause_borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<bool>,
    >(
        self,
        money_market: Arg0,
        pause: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pauseBorrow")
            .argument(&money_market)
            .argument(&pause)
            .original_result()
    }

    /// Changes the seizing status for a specific money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `pause` - A boolean that indicates whether the protocol must be or not paused.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or the Guardian.
    ///
    pub fn pause_seize<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<bool>,
    >(
        self,
        money_market: Arg0,
        pause: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pauseSeize")
            .argument(&money_market)
            .argument(&pause)
            .original_result()
    }

    /// Changes the seizing status (required for liquidations) for all money markets.
    ///
    /// # Arguments:
    ///
    /// - `pause` - A boolean that indicates whether the protocol must be or not paused.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or the Guardian.
    ///
    pub fn pause_global_seize<
        Arg0: ProxyArg<bool>,
    >(
        self,
        pause: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pauseGlobalSeize")
            .argument(&pause)
            .original_result()
    }

    /// Payable endpoint used to enter to a one or many markets, i.e. provide collateral for sender liquidity calculations.
    /// The sender can perform multiple calls to keep adding more collateral.
    ///
    /// # Arguments:
    ///
    /// - `opt_account` - If given, the collateral will be deposited on the name of this account. Can only be performed by a
    ///   whitelisted money market.
    ///
    /// # Notes:
    ///
    /// - Must be paid with one or many valid ESDT Hatom tokens
    ///
    pub fn enter_markets<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_account: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("enterMarkets")
            .argument(&opt_account)
            .original_result()
    }

    /// Exits a given amount of tokens from a given money market, i.e. removes the caller's deposited collateral for
    /// liquidity computations. If the amount of tokens is not specified, all the position is removed.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `opt_tokens` - If given, the amount of collateral tokens to remove.
    ///
    /// # Notes:
    ///
    /// - The provided address must be a whitelisted money market.
    /// - The caller must have collateral in the corresponding money market.
    /// - The amount of tokens to withdraw should not exceed the current deposited amount.
    /// - The caller must be providing the necessary collateral for any outstanding borrows.
    ///
    pub fn exit_market<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        money_market: Arg0,
        opt_tokens: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("exitMarket")
            .argument(&money_market)
            .argument(&opt_tokens)
            .original_result()
    }

    /// Exits a given amount of tokens from a given money market, i.e. removes the caller's deposited collateral for liquidity
    /// computations and redeems the corresponding amount of tokens.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `opt_tokens` - If given, the amount of collateral tokens to remove.
    /// - `opt_underlying_amount` - An optional amount of underlying asset to receive back in exchange for the paid Hatom's
    ///   tokens.
    ///
    /// # Notes:
    ///
    /// - The provided address must be a whitelisted money market.
    /// - The caller must have collateral in the corresponding money market.
    /// - The amount of tokens to withdraw should not exceed the current deposited amount.
    ///
    pub fn exit_market_and_redeem<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<Option<BigUint<Env::Api>>>,
        Arg2: ProxyArg<Option<BigUint<Env::Api>>>,
    >(
        self,
        money_market: Arg0,
        opt_tokens: Arg1,
        opt_underlying_amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue3<EgldOrEsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("exitMarketAndRedeem")
            .argument(&money_market)
            .argument(&opt_tokens)
            .argument(&opt_underlying_amount)
            .original_result()
    }

    /// Removes an account from the given money market when the account has no collateral and no outstanding borrow in the
    /// given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `opt_account` - If given, the address of the account to remove. If not given, the caller's address is used.
    ///
    pub fn remove_account_market<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        money_market: Arg0,
        opt_account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAccountMarket")
            .argument(&money_market)
            .argument(&opt_account)
            .original_result()
    }

    /// Checks whether minting is allowed at a specified money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    ///
    /// # Notes:
    ///
    /// - It does not depend on the account that intends to mint.
    /// - Fails with panic and a clear error message or returns true.
    ///
    pub fn mint_allowed<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("mintAllowed")
            .argument(&money_market)
            .argument(&amount)
            .original_result()
    }

    /// Checks whether an account (redeemer) should be allowed to withdraw a given amount of Hatom tokens from a given
    /// market, i.e. withdraw collateral.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `redeemer` - The account that intends to withdraw the tokens.
    /// - `tokens` - The amount of Hatom tokens to withdraw.
    ///
    /// # Notes:
    ///
    /// - This function is not used when redeeming at a money market, it is only used when redeeming (exiting the market) at
    ///   the controller.
    /// - A simulation of the resulting risk profile is performed.
    /// - Fails with panic and a clear error message, returns false if redeemer would become risky or true if she remains
    ///   solvent.
    ///
    pub fn redeem_allowed<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        redeemer: Arg1,
        tokens: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("redeemAllowed")
            .argument(&money_market)
            .argument(&redeemer)
            .argument(&tokens)
            .original_result()
    }

    /// Checks whether an account (borrower) should be allowed to take a borrow of a given amount on a given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `borrower` - The account that intends to take a borrow.
    /// - `amount` - The amount of underlying to borrow.
    ///
    /// # Notes:
    ///
    /// - Fails with panic and a clear error message, returns false if borrower would become risky or true if she remains
    ///   solvent.
    ///
    pub fn borrow_allowed<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        borrower: Arg1,
        amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrowAllowed")
            .argument(&money_market)
            .argument(&borrower)
            .argument(&amount)
            .original_result()
    }

    /// Checks whether repaying a borrow is allowed at a specified money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `borrower` - The address of the borrower.
    ///
    /// # Notes:
    ///
    /// - It does not depend on the account that intends to repay the borrow.
    ///
    pub fn repay_borrow_allowed<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        borrower: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("repayBorrowAllowed")
            .argument(&money_market)
            .argument(&borrower)
            .original_result()
    }

    /// Checks whether a liquidation is allowed or not to happen, repaying a borrow at a given money market and seizing
    /// collateral at the same or another specified money market.
    ///
    /// # Arguments:
    ///
    /// - `borrow_market` - The money market where the borrower has borrow its underlying.
    /// - `collateral_market` - The money market where the borrower has collateral which is intended to be seized.
    /// - `borrower` - The address of the borrower.
    /// - `amount` - The amount of underlying being repaid by the liquidator.
    ///
    /// # Notes:
    ///
    /// - Borrows at deprecated markets can be fully repaid (the close factor does not play any role).
    /// - Fails with panic and a clear error message, returns false if the borrower cannot be liquidated (i.e. the borrower
    ///   is solvent) or true if the liquidation can be performed (i.e. the borrower is risky and repayment amount does not
    ///   exceeds its maximum allowed).
    ///
    pub fn liquidate_borrow_allowed<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        borrow_market: Arg0,
        collateral_market: Arg1,
        borrower: Arg2,
        amount: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("liquidateBorrowAllowed")
            .argument(&borrow_market)
            .argument(&collateral_market)
            .argument(&borrower)
            .argument(&amount)
            .original_result()
    }

    /// Checks whether seizing is or not allowed.
    ///
    /// # Arguments:
    ///
    /// - `collateral_market` - The money market where the borrower has collateral which is intended to be seized.
    /// - `borrow_market` - The money market where the borrower has borrow its underlying.
    /// - `borrower` - The address of the borrower.
    /// - `_liquidator` - The address of the liquidator (legacy).
    ///
    /// # Notes:
    ///
    /// - Money markets should be whitelisted and share the same Controller.
    ///
    pub fn seize_allowed<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        collateral_market: Arg0,
        borrow_market: Arg1,
        borrower: Arg2,
        _liquidator: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("seizeAllowed")
            .argument(&collateral_market)
            .argument(&borrow_market)
            .argument(&borrower)
            .argument(&_liquidator)
            .original_result()
    }

    /// Updates rewards batches states.
    ///
    /// # Arguments:
    ///
    /// - `supply` - Whether or not to update supply rewards.
    /// - `borrow` - Whether or not to update borrow rewards..
    /// - `money_markets` - The money market addresses to update rewards in. If empty, all whitelisted markets will be used.
    ///
    pub fn update_rewards_batches_state<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        supply: Arg0,
        borrow: Arg1,
        money_markets: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRewardsBatchesState")
            .argument(&supply)
            .argument(&borrow)
            .argument(&money_markets)
            .original_result()
    }

    /// Distributes caller or specified accounts rewards from supply and/or borrow markets, at specific money markets.
    ///
    /// # Arguments:
    ///
    /// - `supply` - Whether or not to distribute supply rewards.
    /// - `borrow` - Whether or not to distribute borrow rewards.
    /// - `money_markets` - The money market addresses to distribute rewards in. If empty, all whitelisted markets will be
    ///   used.
    /// - `accounts` - The addresses to distribute rewards for. If empty, the caller will be used.
    ///
    pub fn distribute_rewards<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg3: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        supply: Arg0,
        borrow: Arg1,
        money_markets: Arg2,
        accounts: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("distributeRewards")
            .argument(&supply)
            .argument(&borrow)
            .argument(&money_markets)
            .argument(&accounts)
            .original_result()
    }

    /// Claims caller or specified accounts rewards from supply and/or borrow markets, at specific money markets.
    ///
    /// # Arguments:
    ///
    /// - `boost` - Whether or not to boost rewards whenever possible.
    /// - `supply` - Whether or not to claim supply rewards.
    /// - `borrow` - Whether or not to claim borrow rewards.
    /// - `money_markets` - The money market addresses to claim rewards in. If empty, all whitelisted markets will be used.
    /// - `accounts` - The addresses to claim rewards for. If empty, the caller will be used.
    /// - `opt_min_boosted_rewards_out`: An optional minimum amount of boosted rewards out.
    ///
    pub fn claim_rewards<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<bool>,
        Arg3: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg4: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg5: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        boost: Arg0,
        supply: Arg1,
        borrow: Arg2,
        money_markets: Arg3,
        accounts: Arg4,
        opt_min_boosted_rewards_out: Arg5,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewards")
            .argument(&boost)
            .argument(&supply)
            .argument(&borrow)
            .argument(&money_markets)
            .argument(&accounts)
            .argument(&opt_min_boosted_rewards_out)
            .original_result()
    }

    /// Sends all rewards from all rewards batches for the given money markets to the given account.
    ///
    /// # Arguments:
    ///
    /// - `boost`: Whether to boost the rewards or not.
    /// - `supply` - Whether or not to claim supply rewards.
    /// - `borrow` - Whether or not to claim borrow rewards.
    /// - `tokens`: An array of rewards tokens.
    /// - `money_markets`: An array of money market addresses in which the rewards distribution will be done.
    /// - `accounts`: An array of account addresses.
    /// - `opt_min_boosted_rewards_out`: An optional minimum amount of boosted rewards out.
    ///
    /// # Notes:
    ///
    /// - If `boost` is enabled, then the rewards will be boosted using the rewards booster.
    /// - If no money markets are specified, then all whitelisted money markets will be used.
    /// - If a provided money market does not have any batch for the rewards tokens, then it will be ignored.
    /// - If no accounts are provided, then only the caller will claim his rewards.
    ///
    pub fn claim_rewards_tokens<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<bool>,
        Arg3: ProxyArg<ManagedVec<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
        Arg4: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg5: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg6: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        boost: Arg0,
        supply: Arg1,
        borrow: Arg2,
        tokens: Arg3,
        money_markets: Arg4,
        accounts: Arg5,
        opt_min_boosted_rewards_out: Arg6,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewardsTokens")
            .argument(&boost)
            .argument(&supply)
            .argument(&borrow)
            .argument(&tokens)
            .argument(&money_markets)
            .argument(&accounts)
            .argument(&opt_min_boosted_rewards_out)
            .original_result()
    }

    /// Checks whether an account is risky or not by computing its current risk profile.
    ///
    /// # Arguments:
    ///
    /// - `account` - The account we wish to analyze.
    ///
    pub fn is_risky<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isRisky")
            .argument(&account)
            .original_result()
    }

    /// Performs a risk profile simulation for a given account, considering its current opened positions and simulating
    /// either redeeming or borrowing (or both) in a given money market. The money market for the simulation must be already
    /// included as an account market. Otherwise, the simulation will not be performed.
    ///
    /// # Arguments:
    ///
    /// - `account` - The account we wish to analyze.
    /// - `this_money_market` - The money market address used for the borrow or redeem simulation (or both).
    /// - `redeem_tokens` - The amount of Hatom tokens to be redeemed for underlying at `this_money_market`.
    /// - `borrow_amount` - The amount of underlying to be borrowed at `this_money_market`.
    /// - `lazy` - If true, the simulation will return a solvent risk profile with a dummy liquidity if the account is not a
    ///   borrower. If false, the simulation will be fully performed, even if it is not a borrower (i.e. Solvent by
    ///   definition).
    ///
    pub fn simulate_risk_profile<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<bool>,
    >(
        self,
        account: Arg0,
        this_money_market: Arg1,
        redeem_tokens: Arg2,
        borrow_amount: Arg3,
        lazy: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, RiskProfile<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("simulateRiskProfile")
            .argument(&account)
            .argument(&this_money_market)
            .argument(&redeem_tokens)
            .argument(&borrow_amount)
            .argument(&lazy)
            .original_result()
    }

    /// A utility function to highlight that this smart contract is a Controller.
    ///
    pub fn is_controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isController")
            .original_result()
    }

    /// Checks whether the specified money market address has already been whitelisted.
    ///
    /// # Arguments:
    ///
    /// - `sc_address` - The address of the money market to check.
    ///
    pub fn is_whitelisted_money_market<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        sc_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isWhitelistedMoneyMarket")
            .argument(&sc_address)
            .original_result()
    }

    /// Checks whether the specified token identifier has already been whitelisted.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The token identifier to check.
    ///
    pub fn is_whitelisted_token_id<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isWhitelistedTokenId")
            .argument(&token_id)
            .original_result()
    }

    /// Checks whether the specified address is a Rewards Booster observer.
    ///
    /// # Arguments:
    ///
    /// - `sc_address` - The address of the market observer to check.
    ///
    pub fn is_booster_observer<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        sc_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isBoosterObserver")
            .argument(&sc_address)
            .original_result()
    }

    /// Checks whether the specified address is a USH Market observer.
    ///
    /// # Arguments:
    ///
    /// - `sc_address` - The address of the market observer to check.
    ///
    pub fn is_ush_market_observer<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        sc_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isUshMarketObserver")
            .argument(&sc_address)
            .original_result()
    }

    /// Checks whether the specified money market is deprecated.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market to check.
    ///
    pub fn is_deprecated<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isDeprecated")
            .argument(&money_market)
            .original_result()
    }

    /// Gets a whitelist or set of supported money market addresses as an array.
    ///
    pub fn get_whitelisted_markets(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedMarkets")
            .original_result()
    }

    /// Gets the the set of money markets addresses in which the account has entered as an array. An account is considered to
    /// be in the market if it has deposited collateral or took a borrow. Currently, after a borrow is fully repaid, the
    /// account is still considered to be in the market.
    ///
    pub fn get_account_markets<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountMarkets")
            .argument(&account)
            .original_result()
    }

    /// Gets the maximum collateral factor allowed
    ///
    pub fn get_max_collateral_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxCollateralFactor")
            .original_result()
    }

    /// Gets the amount of Hatom tokens deposited as collateral for a given money market and account.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `account` - The account we wish to analyze.
    ///
    pub fn get_account_collateral_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountTokens")
            .argument(&money_market)
            .argument(&account)
            .original_result()
    }

    /// Gets the total amount of collateral tokens deposited into the controller for a specific money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market for which to retrieve the total collateral tokens.
    ///
    /// # Notes:
    ///
    /// - If the market has no collateral, returns 0.
    ///
    pub fn get_total_collateral_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalCollateralTokens")
            .argument(&money_market)
            .original_result()
    }

    /// Gets the up to date collateral factor for a specified money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    ///
    pub fn update_and_get_collateral_factor<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAndGetCollateralFactor")
            .argument(&money_market)
            .original_result()
    }

    /// Gets the up to date USH borrower collateral factor for a specified money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    ///
    pub fn update_and_get_ush_borrower_collateral_factor<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAndGetUshBorrowerCollateralFactor")
            .argument(&money_market)
            .original_result()
    }

    /// Updates the collateral factors if possible and returns their updated values.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    ///
    pub fn update_and_get_collateral_factors<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAndGetCollateralFactors")
            .argument(&money_market)
            .original_result()
    }

    /// Gets the current minting status at a given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    ///
    /// # Notes:
    ///
    /// - By default, mint is active (returns the first enum value).
    ///
    pub fn get_mint_status<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMintStatus")
            .argument(&money_market)
            .original_result()
    }

    /// Gets the current borrowing status at a given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    ///
    /// # Notes:
    ///
    /// - By default, borrow is active (returns the first enum value).
    ///
    pub fn get_borrow_status<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowStatus")
            .argument(&money_market)
            .original_result()
    }

    /// Gets the current seizing status at a given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    ///
    /// # Notes:
    ///
    /// - By default, seize is active (returns the first enum value).
    ///
    pub fn get_seize_status<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSeizeStatus")
            .argument(&money_market)
            .original_result()
    }

    /// Gets the current global seizing status at a given money market.
    ///
    /// # Notes:
    ///
    /// - By default, global seize is active (returns the first enum value).
    ///
    pub fn get_global_seize_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getGlobalSeizeStatus")
            .original_result()
    }

    /// Gets the accrued rewards for a given account's address and rewards token ID.
    ///
    /// # Arguments:
    ///
    /// - `supplier` - A reference to a `ManagedAddress` representing the supplier's address.
    /// - `rewards_token_id` - A reference to an `EgldOrEsdtTokenIdentifier` representing the rewards token's ID.
    ///
    pub fn get_account_accrued_rewards<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        supplier: Arg0,
        rewards_token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountAccruedRewards")
            .argument(&supplier)
            .argument(&rewards_token_id)
            .original_result()
    }

    /// Whitelisted money markets can burn their own tokens deposited at the controller.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The token identifier for the Hatom token.
    /// - `tokens` - The amount of tokens to be burnt.
    ///
    /// # Notes:
    ///
    /// - Can only be called by a whitelisted money market.
    /// - A money market can only burn Hatom tokens corresponding to their own token type.
    /// - There is no need to update the total collateral tokens for the money market because it is assumed that they have
    ///   already exited the market and are being redeemed.
    ///
    pub fn burn_tokens<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_id: Arg0,
        tokens: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("burnTokens")
            .argument(&token_id)
            .argument(&tokens)
            .original_result()
    }

    /// Whitelisted money markets can transfer their own tokens to a given account.
    ///
    /// # Arguments:
    ///
    /// - `to` - The address of the account to which the tokens will be transferred.
    /// - `token_payment` - The token payment to be transferred.
    ///
    /// # Notes:
    ///
    /// - Can only be called by a whitelisted money market.
    /// - A money market can only transfer Hatom tokens corresponding to their own token type.
    /// - There is no need to update the total collateral tokens for the money market because it is assumed that they have
    ///   already exited the market and are being transferred.
    ///
    pub fn transfer_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EsdtTokenPayment<Env::Api>>,
    >(
        self,
        to: Arg0,
        token_payment: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("transferTokens")
            .argument(&to)
            .argument(&token_payment)
            .original_result()
    }

    /// Computes the amount of Hatom tokens to be seized given an underlying repayment amount performed by the liquidator.
    /// Takes into consideration the liquidation incentive, such that the liquidator gets tokens at a discount.
    ///
    /// # Arguments:
    ///
    /// - `borrow_market` - The money market where the borrower has borrow its underlying.
    /// - `collateral_market` - The money market where the borrower has collateral which is intended to be seized.
    /// - `amount` - The amount of underlying being repaid by the liquidator.
    ///
    pub fn tokens_to_seize<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        borrow_market: Arg0,
        collateral_market: Arg1,
        amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("tokensToSeize")
            .argument(&borrow_market)
            .argument(&collateral_market)
            .argument(&amount)
            .original_result()
    }

    /// Stores the guardian address.
    pub fn pause_guardian(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPauseGuardian")
            .original_result()
    }

    /// Stores the rewards manager address.
    pub fn rewards_manager(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsManager")
            .original_result()
    }

    /// Stores a whitelisted market address given a token identifier.
    pub fn money_markets<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMoneyMarketByTokenId")
            .argument(&token_id)
            .original_result()
    }

    /// Stores both the underlying identifier and the token identifier associated to a whitelisted money market.
    pub fn identifiers<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (EgldOrEsdtTokenIdentifier<Env::Api>, TokenIdentifier<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getIdentifiersByMoneyMarket")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the set of addresses that belong to a given money market.
    pub fn market_members<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMarketMembers")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the maximum amount of markets an account can enter at any given point in time.
    pub fn max_markets_per_account(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxMarketsPerAccount")
            .original_result()
    }

    /// Stores the price oracle smart contract address.
    pub fn price_oracle(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceOracle")
            .original_result()
    }

    /// Stores the collateral factor for each money market.
    pub fn collateral_factor<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralFactor")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the collateral factor for each money market taken into consideration if the account has borrowed USH.
    pub fn ush_borrower_collateral_factor<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshBorrowerCollateralFactor")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the next collateral factors for each money market.
    pub fn next_collateral_factors<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNextCollateralFactor")
            .argument(&money_market)
            .original_result()
    }

    /// A supported money market might have a liquidity cap, which is stored here.
    pub fn liquidity_cap<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidityCap")
            .argument(&money_market)
            .original_result()
    }

    /// A supported money market might have a borrowing cap, which is stored here.
    pub fn borrow_cap<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowCap")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the rewards index for a given account and rewards token in the specified money market.
    pub fn account_batch_rewards_index<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountRewardsIndex")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&account)
            .original_result()
    }

    /// Stores the ID of the next rewards batch in the specified money market.
    pub fn next_rewards_batch_id<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNextRewardsBatchId")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the maximum amount of batches allowed per market.
    pub fn max_rewards_batches<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxRewardsBatchesPerMarket")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the maximum allowed slippage.
    pub fn max_slippage(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxSlippage")
            .original_result()
    }

    /// Stores the list of rewards batches in the specified money market.
    pub fn rewards_batches<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, RewardsBatch<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsBatches")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the undistributed rewards for a given rewards token identifier.
    pub fn undistributed_rewards<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUndistributedRewards")
            .argument(&token_id)
            .original_result()
    }

    /// Stores the current position of a rewards batch in the specified money market at the corresponding VecMapper.
    pub fn rewards_batch_position<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsBatchPosition")
            .argument(&money_market)
            .argument(&batch_id)
            .original_result()
    }

    /// Stores the rewards batch booster for a given rewards token identifier.
    pub fn rewards_booster<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, RewardsBooster<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsBooster")
            .argument(&token_id)
            .original_result()
    }

    /// Stores wrapped EGLD smart contract address.
    pub fn egld_wrapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldWrapper")
            .original_result()
    }

    /// Stores the token identifier of the wrapped EGLD token.
    pub fn wegld_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWegldId")
            .original_result()
    }

    /// Stores the governance token identifier.
    pub fn governance_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getGovernanceTokenId")
            .original_result()
    }

    /// Stores the xExchange Router address.
    pub fn router(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRouter")
            .original_result()
    }

    /// Stores the boosting state.
    pub fn boosting_state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBoostingState")
            .original_result()
    }

    /// Stores whether boosting is or not supported.
    pub fn rewards_batch_boosting_supported(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isRewardsBatchBoostingSupported")
            .original_result()
    }

    /// Stores the Rewards Booster smart contract address.
    pub fn booster_observer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBoosterObserver")
            .original_result()
    }

    /// Stores the USH Money Market observer.
    pub fn ush_market_observer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshMarketObserver")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct RewardsBatch<Api>
where
    Api: ManagedTypeApi,
{
    pub id: usize,
    pub money_market: ManagedAddress<Api>,
    pub market_type: MarketType,
    pub token_id: EgldOrEsdtTokenIdentifier<Api>,
    pub amount: BigUint<Api>,
    pub distributed_amount: BigUint<Api>,
    pub speed: BigUint<Api>,
    pub index: BigUint<Api>,
    pub last_time: u64,
    pub end_time: u64,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq, ManagedVecItem)]
pub enum MarketType {
    Supply,
    Borrow,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct RewardsBooster<Api>
where
    Api: ManagedTypeApi,
{
    pub token_id: EgldOrEsdtTokenIdentifier<Api>,
    pub premium: BigUint<Api>,
    pub amount_left: BigUint<Api>,
    pub distributed_amount: BigUint<Api>,
    pub swap_path: ManagedVec<Api, SwapStep<Api>>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct SwapStep<Api>
where
    Api: ManagedTypeApi,
{
    pub pair_address: ManagedAddress<Api>,
    pub input_token_id: TokenIdentifier<Api>,
    pub output_token_id: TokenIdentifier<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Clone, Debug)]
pub enum RiskProfile<Api>
where
    Api: ManagedTypeApi,
{
    Solvent(BigUint<Api>),
    RiskyOrInsolvent(BigUint<Api>),
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Clone, Copy, Debug)]
pub enum Status {
    Active,
    Paused,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Clone, Copy, Debug)]
pub enum State {
    Inactive,
    Active,
}
