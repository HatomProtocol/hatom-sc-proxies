// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct DiscountRateModelProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for DiscountRateModelProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = DiscountRateModelProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        DiscountRateModelProxyMethods { wrapped_tx: tx }
    }
}

pub struct DiscountRateModelProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> DiscountRateModelProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the Discount Rate Model smart contract.
    ///
    /// # Arguments:
    ///
    /// - `ush_money_market` - The USH Money Market smart contract address.
    /// - `opt_admin` - An optional admin address for the contract.
    ///
    /// Notes:
    ///
    /// - If the admin address is not provided, the admin will be set as the deployer.
    ///
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        ush_money_market: Arg0,
        opt_admin: Arg1,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&ush_money_market)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> DiscountRateModelProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> DiscountRateModelProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address.
    ///
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one.
    ///
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address.
    ///
    /// # Arguments:
    ///
    /// - `new_pending_admin` - The new pending admin address.
    ///
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint.
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// A utility function to highlight that this smart contract is a Discount Rate Model.
    ///
    pub fn is_discount_rate_model(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isDiscountRateModel")
            .original_result()
    }

    /// Gets the discount data for all markets that have been granted a discount.
    ///
    pub fn get_discounts_data(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, DiscountData<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDiscountsData")
            .original_result()
    }

    /// Returns the current number of discounts.
    ///
    pub fn get_discounts_count(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDiscountsCount")
            .original_result()
    }

    /// Retrieves the exchange rate of a money market based on the specified method.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - Address of the money market contract.
    /// - `fx_type` - The method to use for fetching the exchange rate (`Cached` or `Updated`).
    ///
    /// # Notes:
    ///
    /// - When using `Cached`, the function returns the exchange rate stored previously in the `last_exchange_rate`.
    /// - When using `Updated`, the function fetches the latest exchange rate, stores it as the new `last_exchange_rate`, and returns the updated value.
    ///
    pub fn get_exchange_rate<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ExchangeRateType>,
    >(
        self,
        money_market: Arg0,
        fx_type: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getExchangeRate")
            .argument(&money_market)
            .argument(&fx_type)
            .original_result()
    }

    /// Gets the effective discount rate for the specified borrower and borrow amount in WAD units.
    ///
    /// # Arguments:
    ///
    /// - `borrower` - The borrower address.
    /// - `borrow` - The borrowed amount.
    ///
    pub fn get_account_discount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ExchangeRateType>,
    >(
        self,
        borrower: Arg0,
        borrow: Arg1,
        fx_type: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountDiscount")
            .argument(&borrower)
            .argument(&borrow)
            .argument(&fx_type)
            .original_result()
    }

    /// Sets the discount for a specific money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The money market address.
    /// - `discount` - The discount in bps.
    ///
    pub fn set_discount_data<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        discount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDiscountData")
            .argument(&money_market)
            .argument(&discount)
            .original_result()
    }

    /// Removes the discount data for a specific money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The money market address.
    ///
    pub fn remove_discount_data<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeDiscountData")
            .argument(&money_market)
            .original_result()
    }

    /// Updates the discount of a specific money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The money market address.
    /// - `discount` - The discount in bps.
    ///
    pub fn update_discount_data<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        discount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateDiscountData")
            .argument(&money_market)
            .argument(&discount)
            .original_result()
    }

    /// Stores the Controller address.
    pub fn controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    /// Stores the USH money market address.
    pub fn ush_money_market(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshMoneyMarket")
            .original_result()
    }

    /// Stores the USH Token Identifier.
    pub fn ush_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshTokenId")
            .original_result()
    }

    /// Stores whether the money market has discount data or not.
    pub fn has_discount_data<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("hasDiscountData")
            .argument(&money_market)
            .original_result()
    }

    /// Stores all the discounts data ordered by discounts.
    pub fn discounts_data_list(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, DiscountData<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDiscountsDataList")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct DiscountData<Api>
where
    Api: ManagedTypeApi,
{
    pub money_market: ManagedAddress<Api>,
    pub underlying_id: EgldOrEsdtTokenIdentifier<Api>,
    pub discount: BigUint<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Eq, Copy, Clone, Debug)]
pub enum ExchangeRateType {
    Cached,
    Updated,
}
