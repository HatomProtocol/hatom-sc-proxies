// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct InterestRateModelProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for InterestRateModelProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = InterestRateModelProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        InterestRateModelProxyMethods { wrapped_tx: tx }
    }
}

pub struct InterestRateModelProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> InterestRateModelProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the Interest Rate Model smart contract with the given parameters.
    ///
    /// The `r0_y`, `m1_y`, `m2_y`, `uo`, and `r_max` parameters describe the piecewise linear function that determines the
    /// borrow rate. They are provided in per year term basis and are translated to a per second term basis using constants
    /// `WAD` and `SECONDS_PER_YEAR`.
    ///
    /// # Arguments:
    ///
    /// - `r0_y` - The base borrow rate per year.
    /// - `m1_y` - The first slope of the borrow rate function per year.
    /// - `m2_y` - The last slope of the borrow rate function per year.
    /// - `uo` - The optimal utilization.
    /// - `r_max` - The maximum borrow rate per second.
    ///
    pub fn init<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        r0_y: Arg0,
        m1_y: Arg1,
        m2_y: Arg2,
        uo: Arg3,
        r_max: Arg4,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&r0_y)
            .argument(&m1_y)
            .argument(&m2_y)
            .argument(&uo)
            .argument(&r_max)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> InterestRateModelProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> InterestRateModelProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns true to indicate that this contract is an interest rate model.
    pub fn is_interest_rate_model(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isInterestRateModel")
            .original_result()
    }

    /// Returns the utilization rate for the given amount of borrows and liquidity. Utilization rate is calculated as borrows
    /// divided by liquidity. If borrows are zero, returns zero. If liquidity is zero, returns the utilization rate that
    /// yields the maximum borrow rate.
    ///
    /// # Arguments:
    ///
    /// - `borrows` - The total amount borrowed.
    /// - `liquidity` - The total amount of funds available for borrowing.
    ///
    pub fn get_utilization<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        borrows: Arg0,
        liquidity: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUtilization")
            .argument(&borrows)
            .argument(&liquidity)
            .original_result()
    }

    /// Returns the current model parameters used to calculate the borrow rate, as a tuple of:
    ///
    /// - Base rate (r0)
    /// - First slope (m1)
    /// - Last slope (m2)
    /// - Optimal utilization (uo)
    /// - Maximum borrow rate (r_max)
    ///
    pub fn get_model_parameters(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getModelParameters")
            .original_result()
    }

    /// Computes the borrow rate per second based on the current state of the model, the total borrows and total liquidity.
    ///
    /// # Arguments:
    ///
    /// - `borrows` - The total amount of borrows in the market.
    /// - `liquidity` - The total amount of cash available to be borrowed or used as collateral.
    ///
    pub fn get_borrow_rate<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        borrows: Arg0,
        liquidity: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowRate")
            .argument(&borrows)
            .argument(&liquidity)
            .original_result()
    }

    /// Calculates the current supply rate per second given the total amount of borrows, the total amount of underlying
    /// assets, and the current reserve factor.
    ///
    /// # Arguments:
    ///
    /// - `borrows` - The total amount of outstanding borrows of the underlying asset.
    /// - `liquidity` - The total amount of the underlying asset supplied by the users.
    /// - `reserve_factor` - The current reserve factor applied to the market.
    ///
    pub fn get_supply_rate<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        borrows: Arg0,
        liquidity: Arg1,
        reserve_factor: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSupplyRate")
            .argument(&borrows)
            .argument(&liquidity)
            .argument(&reserve_factor)
            .original_result()
    }

    ///
    /// - `borrows` - The current borrow balance.
    /// - `liquidity` - The current liquidity balance.
    /// - `reserve_factor` - The reserve factor for the asset.
    ///
    pub fn get_rates<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        borrows: Arg0,
        liquidity: Arg1,
        reserve_factor: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRates")
            .argument(&borrows)
            .argument(&liquidity)
            .argument(&reserve_factor)
            .original_result()
    }

    /// Stores the base rate used in the interest rate calculation.
    pub fn base_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseRate")
            .original_result()
    }

    /// Stores the slope of the borrow rate up to the optimal utilization point.
    pub fn first_slope(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFirstSlope")
            .original_result()
    }

    /// Stores the slope of the borrow rate after the optimal utilization point.
    pub fn last_slope(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastSlope")
            .original_result()
    }

    /// Stores the optimal utilization point for the interest rate calculation.
    pub fn optimal_utilization(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOptimalUtilization")
            .original_result()
    }

    /// Stores the maximum borrow rate allowed by the interest rate model.
    pub fn max_borrow_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxBorrowRate")
            .original_result()
    }
}
