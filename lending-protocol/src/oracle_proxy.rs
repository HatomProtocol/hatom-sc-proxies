// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct OracleProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for OracleProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = OracleProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        OracleProxyMethods { wrapped_tx: tx }
    }
}

pub struct OracleProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> OracleProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the Oracle.
    ///
    /// # Arguments:
    ///
    /// - `egld_wrapper` - The wrapped EGLD smart contract for the pertinent shard.
    /// - `xexchange_pricing_method` - The xExchange pricing methods allowed.
    /// - `opt_admin` - An optional admin address for the contract.
    ///
    /// Notes:
    ///
    /// - If the contract is being deployed for the first time, the admin address will be set.
    /// - If the admin address is not provided, the admin will be set as the deployer.
    /// - If the contract is being upgraded, the admin address will not be overwritten.
    /// - A new implementation could be deployed instead of performing an upgrade.
    ///
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ExchangePricingMethod>,
        Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        egld_wrapper: Arg0,
        xexchange_pricing_method: Arg1,
        opt_admin: Arg2,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&egld_wrapper)
            .argument(&xexchange_pricing_method)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> OracleProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> OracleProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address.
    ///
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one.
    ///
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address.
    ///
    /// # Arguments:
    ///
    /// - `new_pending_admin` - The new pending admin address.
    ///
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint.
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// A utility function to highlight that this smart contract is a Price Oracle.
    ///
    pub fn is_price_oracle(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isPriceOracle")
            .original_result()
    }

    /// Sets the Guardian of the Oracle.
    ///
    /// # Arguments:
    ///
    /// - `guardian` - The address of the new Guardian.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_guardian<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        guardian: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setGuardian")
            .argument(&guardian)
            .original_result()
    }

    /// Unpauses the token pricing.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The token identifier.
    /// - `opt_first_anchor_tolerance` - Optional first anchor tolerance.
    /// - `opt_last_anchor_tolerance` - Optional last anchor tolerance.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or guardian.
    /// - The pricing might have been paused by the `Default` pricing algorithm.
    /// - The guardian can change the anchor tolerances if the token has been paused.
    ///
    pub fn unpause_token<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
        Arg2: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        token_id: Arg0,
        opt_first_anchor_tolerance: Arg1,
        opt_last_anchor_tolerance: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpauseToken")
            .argument(&token_id)
            .argument(&opt_first_anchor_tolerance)
            .argument(&opt_last_anchor_tolerance)
            .original_result()
    }

    /// Pauses the token pricing.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The token identifier.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or guardian.
    ///
    pub fn pause_token<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pauseToken")
            .argument(&token_id)
            .original_result()
    }

    /// Allows pricing of tokens using the Price Aggregator Smart Contract as the price provider.
    ///
    /// # Arguments:
    ///
    /// - `price_aggregator_address` - The Price Aggregator address.
    /// - `round_duration_tolerance` - The round duration tolerance as a percentage of the fetched round duration as a
    ///   percentage in BPS.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - Since all token prices are expressed in USD, the Price Aggregator must provide a price for the EGLD/USD.
    /// - Checks all supported tokens can be priced using the Price Aggregator.
    ///
    pub fn support_price_aggregator<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        price_aggregator_address: Arg0,
        round_duration_tolerance: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportPriceAggregator")
            .argument(&price_aggregator_address)
            .argument(&round_duration_tolerance)
            .original_result()
    }

    /// Updates the current round duration by making a call to the Price Aggregator and using a given tolerance.
    ///
    /// # Arguments:
    ///
    /// - `round_duration_tolerance` - The round duration tolerance as a percentage of the fetched round duration and in BPS.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The Price Aggregator must have been already supported.
    ///
    pub fn update_round_duration<
        Arg0: ProxyArg<u64>,
    >(
        self,
        round_duration_tolerance: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRoundDuration")
            .argument(&round_duration_tolerance)
            .original_result()
    }

    /// Supports a native token for pricing. Native tokens are tokens that can be priced by xExchange.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The token identifier.
    /// - `token_decimals` - The token decimals.
    /// - `xexchange_pair_address` - The xExchange Pair address.
    /// - `first_anchor_tolerance` - The first anchor tolerance in wad.
    /// - `last_anchor_tolerance` - The last anchor tolerance in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - Needs both xExchange and Price Aggregator support.
    /// - The pair address must be a xExchange pair contract in which either the first or second token identifier is WEGLD.
    /// - The token identifier that is not the WEGLD token identifier is the token identifier for which the price will be
    ///   provided.
    /// - Assumes that the other token in Price Aggregator price feed is always USD.
    /// - Sets the Default method as pricing method and makes sure it is working properly.
    /// - Tokens cannot be removed, they can only be modified through this endpoint. This is because the Controller checks if
    ///   a token is already supported when supporting its corresponding market. Removing a token here would break such
    ///   check. Notice that the only parameter that could have been incorrectly set is the token decimals. All other
    ///   parameters are cross check with the xExchange pair contract.
    ///
    pub fn support_native_token<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
        Arg4: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_id: Arg0,
        token_decimals: Arg1,
        xexchange_pair_address: Arg2,
        first_anchor_tolerance: Arg3,
        last_anchor_tolerance: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportNativeToken")
            .argument(&token_id)
            .argument(&token_decimals)
            .argument(&xexchange_pair_address)
            .argument(&first_anchor_tolerance)
            .argument(&last_anchor_tolerance)
            .original_result()
    }

    /// Supports sEGLD pricing using the EGLD Liquid Staking smart contract as the price provider.
    ///
    /// # Arguments:
    ///
    /// - `liquid_staking_sc` - The EGLD Liquid Staking smart contract address.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn support_egld_ls_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        liquid_staking_sc: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportEgldLsToken")
            .argument(&liquid_staking_sc)
            .original_result()
    }

    /// Supports SwTAO pricing using the TAO Liquid Staking smart contract as the price provider.
    ///
    /// # Arguments:
    ///
    /// - `liquid_staking_sc` - The TAO Liquid Staking smart contract address.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The TAO token must have been already supported in order to support sTAO token pricing.
    ///
    pub fn support_tao_ls_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        liquid_staking_sc: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportTaoLsToken")
            .argument(&liquid_staking_sc)
            .original_result()
    }

    /// Supports USH pricing using the Price Aggregator and a fallback token (USDC) as the price providers.
    ///
    /// # Arguments:
    ///
    /// - `ush_minter` - The USH Minter smart contract address.
    /// - `fallback_token_id` - The fallback token identifier, currently USDC.
    /// - `first_anchor_tolerance` - The first anchor tolerance in wad.
    /// - `last_anchor_tolerance` - The last anchor tolerance in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn support_ush_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ush_minter: Arg0,
        fallback_token_id: Arg1,
        first_anchor_tolerance: Arg2,
        last_anchor_tolerance: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportUshToken")
            .argument(&ush_minter)
            .argument(&fallback_token_id)
            .argument(&first_anchor_tolerance)
            .argument(&last_anchor_tolerance)
            .original_result()
    }

    /// Sets a new fallback token for USH pricing.
    ///
    /// # Arguments:
    ///
    /// - `fallback_token_id` - The new fallback token identifier.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The fallback token must be supported and whitelisted as a valid fallback token.
    ///
    pub fn set_ush_fallback_token<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        fallback_token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setUshFallbackToken")
            .argument(&fallback_token_id)
            .original_result()
    }

    /// Sets a pricing method for the given token.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The ESDT token identifier.
    /// - `pricing_method` - The pricing method.
    ///
    pub fn set_pricing_method<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<PricingMethod>,
    >(
        self,
        token_id: Arg0,
        pricing_method: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPricingMethod")
            .argument(&token_id)
            .argument(&pricing_method)
            .original_result()
    }

    /// Sets a new first and last anchor tolerances for a given token.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The token identifier.
    /// - `first_anchor_tolerance` - The new first anchor tolerance in wad.
    /// - `last_anchor_tolerance` - The new last anchor tolerance in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The token must have been already supported.
    /// - An anchor tolerance is the maximum allowed price change between the anchor price and the reporter price.
    /// - An anchor tolerance equal to 0 implies that the anchor price and reporter price should be equal.
    /// - An anchor tolerance equal to bps = 1e4 = 100%, allows an upwards 100% price change and 50% downwards price change.
    /// - Anchor tolerances can be higher than 100%.
    ///
    pub fn set_anchor_tolerances<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token_id: Arg0,
        first_anchor_tolerance: Arg1,
        last_anchor_tolerance: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAnchorTolerances")
            .argument(&token_id)
            .argument(&first_anchor_tolerance)
            .argument(&last_anchor_tolerance)
            .original_result()
    }

    /// Returns the token price in EGLD and in WAD units.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The identifier of the token to retrieve the price of.
    ///
    /// # Notes:
    ///
    /// - The WEGLD price always equals to one.
    /// - The SEGLD price is retrieved from the Liquid Staking smart contract.
    ///
    pub fn get_price_in_egld<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPrice")
            .argument(&token_id)
            .original_result()
    }

    /// Returns the xExchange price of a token in EGLD, based on its paired liquidity pool reserves.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The identifier of the token for which to retrieve the price.
    ///
    pub fn get_xexchange_instantaneous_price_in_egld<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getXExchangeInstantaneousPriceInEgld")
            .argument(&token_id)
            .original_result()
    }

    /// Returns the safe price of a token in EGLD using the xExchange Protocol.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The identifier of the token for which the safe price is calculated.
    ///
    pub fn get_xexchange_safe_price_in_egld<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getXExchangeSafePriceInEgld")
            .argument(&token_id)
            .original_result()
    }

    /// Returns the price of a given token in EGLD, as reported by the Price Aggregator.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The identifier of the token.
    ///
    pub fn get_price_aggregator_price_in_egld<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceAggregatorPriceInEgld")
            .argument(&token_id)
            .original_result()
    }

    ///  Stores wrapped EGLD smart contract address.
    pub fn egld_wrapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldWrapper")
            .original_result()
    }

    /// Stores the token identifier of the wrapped EGLD token.
    pub fn wegld_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWegldId")
            .original_result()
    }

    /// Stores the address of the EGLD liquid staking smart contract.
    pub fn liquid_staking(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidStakingAddress")
            .original_result()
    }

    /// Stores the address of the TAO liquid staking smart contract.
    pub fn tao_liquid_staking(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTaoLiquidStakingAddress")
            .original_result()
    }

    /// Stores the USH Minter smart contract address.
    pub fn ush_minter(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshMinter")
            .original_result()
    }

    /// Stores the token identifier of the liquid staking token.
    pub fn ls_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLsTokenId")
            .original_result()
    }

    /// Stores the token identifier of the liquid staking TAO token.
    pub fn stao_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStaoTokenId")
            .original_result()
    }

    /// Stores the USH token identifier.
    pub fn ush_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshTokenId")
            .original_result()
    }

    pub fn ush_fallback_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshFallbackTokenId")
            .original_result()
    }

    /// Stores the xExchange pricing method.
    pub fn xexchange_pricing_method(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ExchangePricingMethod> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getXExchangePricingMethod")
            .original_result()
    }

    /// Stores the guardian address.
    pub fn guardian(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getGuardian")
            .original_result()
    }

    /// Stores the address of the Price Aggregator.
    pub fn price_aggregator_address(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceAggregatorAddress")
            .original_result()
    }

    /// Stores the effective round duration based on the Price Aggregator round duration.
    pub fn round_duration(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRoundDuration")
            .original_result()
    }

    /// Whitelisted tokens, i.e. supported tokens.
    pub fn whitelisted_tokens(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedTokens")
            .original_result()
    }

    /// Stores the supported tokens.
    pub fn supported_tokens<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenData<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSupportedTokens")
            .argument(&token_id)
            .original_result()
    }

    /// Stores the pricing method for each token.
    pub fn pricing_method<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, PricingMethod> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPricingMethod")
            .argument(&token_id)
            .original_result()
    }

    /// Stores the last reported price for each token.
    pub fn last_price<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastPrice")
            .argument(&token_id)
            .original_result()
    }

    /// Stores whether the token has an unreliable price.
    pub fn has_unreliable_price<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("hasUnreliablePrice")
            .argument(&token_id)
            .original_result()
    }

    /// Stores whether the token pricing is paused.
    pub fn is_token_paused<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isPaused")
            .argument(&token_id)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Clone, Copy, Debug)]
pub enum ExchangePricingMethod {
    None,
    SafePriceOnly,
    InstantaneousPriceOnly,
    All,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Eq)]
pub struct TokenData<Api>
where
    Api: ManagedTypeApi,
{
    pub token_type: TokenType,
    pub identifier: TokenIdentifier<Api>,
    pub unit_price: BigUint<Api>,
    pub ticker: ManagedBuffer<Api>,
    pub decimals: usize,
    pub exp: BigUint<Api>,
    pub xexchange_pair: Option<ExchangePair<Api>>,
    pub tolerances: Option<ToleranceData<Api>>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Eq)]
pub enum TokenType {
    None,
    Native,
    Synthetic,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Eq)]
pub struct ExchangePair<Api>
where
    Api: ManagedTypeApi,
{
    pub address: ManagedAddress<Api>,
    pub token0: TokenIdentifier<Api>,
    pub token1: TokenIdentifier<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Eq, Clone)]
pub struct ToleranceData<Api>
where
    Api: ManagedTypeApi,
{
    pub first_upper_bound_ratio: BigUint<Api>,
    pub first_lower_bound_ratio: BigUint<Api>,
    pub last_upper_bound_ratio: BigUint<Api>,
    pub last_lower_bound_ratio: BigUint<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Debug)]
pub enum PricingMethod {
    None,
    Default,
    Instantaneous,
    Safe,
    PriceAggregator,
}
