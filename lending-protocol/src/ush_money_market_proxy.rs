// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct UshMoneyMarketProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for UshMoneyMarketProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = UshMoneyMarketProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        UshMoneyMarketProxyMethods { wrapped_tx: tx }
    }
}

pub struct UshMoneyMarketProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> UshMoneyMarketProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the USH Money Market.
    ///
    /// # Arguments:
    ///
    /// - `controller` - The Controller smart contract address.
    /// - `ush_minter` - The USH Minter smart contract address.
    /// - `opt_admin` - An optional admin address for the contract.
    ///
    /// Notes:
    ///
    /// - If the admin address is not provided, the admin will be set as the deployer.
    ///
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        controller: Arg0,
        ush_minter: Arg1,
        opt_admin: Arg2,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&controller)
            .argument(&ush_minter)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> UshMoneyMarketProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> UshMoneyMarketProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Issues Hatom USH.
    ///
    pub fn issue_hatom_ush(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issueHatomUSH")
            .original_result()
    }

    /// Sets minting and burning roles for the Money Market smart contract with respect to Hatom USH.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_market_roles(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMarketRoles")
            .original_result()
    }

    /// Returns the current admin address.
    ///
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one.
    ///
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address.
    ///
    /// # Arguments:
    ///
    /// - `new_pending_admin` - The new pending admin address.
    ///
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint.
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// A borrower requests USH from the money market.
    ///
    /// # Arguments:
    ///
    /// - `ush_amount` - The requested amount of USH.
    ///
    pub fn borrow<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ush_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrow")
            .argument(&ush_amount)
            .original_result()
    }

    /// A utility function to highlight that this smart contract implements the Money Market api that Controller requires.
    /// This function has been added such that this smart contract can be used as a market on the Lending Protocol.
    ///
    pub fn is_money_market(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isMoneyMarket")
            .original_result()
    }

    /// A utility function to highlight that this smart contract implements the USH Market Observer api that Controller
    /// requires. This function has been added such that this smart contract can be used as a market observer on the Lending
    /// Protocol.
    ///
    pub fn is_ush_market(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isUshMarket")
            .original_result()
    }

    /// Checks whether the current state of the smart contract is active.
    ///
    pub fn is_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isActive")
            .original_result()
    }

    /// Checks whether the current state of the smart contract is finalized.
    ///
    pub fn is_finalized(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isFinalized")
            .original_result()
    }

    /// Checks whether the Hatom token has been already issued.
    ///
    pub fn is_hush_issued(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isHushIssued")
            .original_result()
    }

    /// This method is one of the most important methods of the protocol, as it accrues the borrows interest and distributes
    /// that amount into reserves (including revenue and staking rewards). In order to do that, it solves the money market
    /// dynamics using an Euler scheme.
    ///
    pub fn accrue_interest(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("accrueInterest")
            .original_result()
    }

    /// Accrues interest if a sufficient amount of time has elapsed since the last accrual.
    ///
    pub fn try_accrue_interest(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("tryAccrueInterest")
            .original_result()
    }

    /// Adds an specified amount of USH coming as a payment to the USH money market reserves.
    ///
    /// Notes:
    ///
    /// - The USH amount is added as protocol revenue.
    /// - Must be paid with USH.
    ///
    pub fn add_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addReserves")
            .original_result()
    }

    /// Translates a USH amount to HUSH tokens.
    ///
    /// # Arguments:
    ///
    /// - `ush_amount` - the amount of USH to be converted to HUSH.
    ///
    pub fn ush_to_hush<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ush_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("ushToHush")
            .argument(&ush_amount)
            .original_result()
    }

    /// Translates HUSH tokens to USH amount.
    ///
    /// # Arguments:
    ///
    /// - `tokens` - the amount of HUSH to be converted to USH.
    ///
    pub fn hush_to_ush<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        tokens: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("hushToUsh")
            .argument(&tokens)
            .original_result()
    }

    /// Returns the money market identifiers, i.e. the underlying identifier and the token identifier as a tuple.
    ///
    pub fn get_money_market_identifiers(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (EgldOrEsdtTokenIdentifier<Env::Api>, TokenIdentifier<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMoneyMarketIdentifiers")
            .original_result()
    }

    /// Returns the updated amount of borrows.
    ///
    pub fn current_total_borrows(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentTotalBorrows")
            .original_result()
    }

    /// Returns the total principal such that it can be used as a base to calculate amounts that depend on the borrows
    /// amounts, such as user rewards.
    ///
    pub fn get_base_total_borrows(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseTotalBorrows")
            .original_result()
    }

    /// Returns the updated amount of reserves.
    ///
    pub fn current_total_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentTotalReserves")
            .original_result()
    }

    /// Returns the updated amount of staking rewards.
    ///
    pub fn get_current_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentStakingRewards")
            .original_result()
    }

    /// Returns the updated amount of historical staking rewards.
    ///
    pub fn get_current_historical_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentHistoricalStakingRewards")
            .original_result()
    }

    /// Returns the updated amount of revenue.
    ///
    pub fn get_current_revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentRevenue")
            .original_result()
    }

    /// Returns the amount of liquidity, which in this market equals the amount of HUSH in circulation, i.e. the USH being
    /// used as collateral.
    ///
    pub fn get_liquidity(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidity")
            .original_result()
    }

    /// Returns a fixed reserve factor fixed to 100%. This function is used by the Controller to verify if a money market is
    /// deprecated or not.
    ///
    pub fn get_reserve_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReserveFactor")
            .original_result()
    }

    /// Returns the address of the Controller smart contract if set.
    ///
    pub fn get_controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    /// Returns the updated borrow amount of the given account.
    ///
    pub fn current_account_borrow_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCurrentAccountBorrowAmount")
            .argument(&account)
            .original_result()
    }

    /// Returns the borrow amount of the given account up to the last interaction that accrued interest or up to the current
    /// time if a sufficient amount of time has elapsed since the last accrual.
    ///
    pub fn reliable_account_borrow_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReliableAccountBorrowAmount")
            .argument(&account)
            .original_result()
    }

    /// Returns the borrow amount of the given account up to the last interaction that accrued interest.
    ///
    pub fn stored_account_borrow_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStoredAccountBorrowAmount")
            .argument(&account)
            .original_result()
    }

    /// Returns the account principal such that it can be used to calculate amounts that depend on the borrows amounts, such
    /// as user rewards.
    ///
    pub fn base_account_borrow_amount<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseAccountBorrowAmount")
            .argument(&account)
            .original_result()
    }

    /// Returns the market exchange rate (fixed to one) and the borrow amount of the given account up to the last interaction
    /// that accrued interest, in one shot.
    ///
    /// # Arguments:
    ///
    /// - `account` - The account's address.
    ///
    pub fn get_account_snapshot<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountSnapshot")
            .argument(&account)
            .original_result()
    }

    /// Returns the market exchange rate (fixed to one) and the borrow amount of the given account up to the last interaction
    /// that accrued interest or up to the current time if a sufficient amount of time has elapsed since the last accrual, in
    /// one shot.
    ///
    /// # Arguments:
    ///
    /// - `account` - The account's address.
    ///
    pub fn get_reliable_account_snapshot<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReliableAccountSnapshot")
            .argument(&account)
            .original_result()
    }

    /// Returns the borrow index of the market up to the last interaction that accrued interest or its initial condition.
    /// Notice that the borrow index is a mechanism that allows updating all account borrows without having to loop into each
    /// account when there is an interaction with the protocol that accrues interests.
    ///
    pub fn get_borrow_index(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowIndex")
            .original_result()
    }

    /// Returns the exchange rate between underlying and tokens (collateral). Since USH will be used as collateral, the
    /// exchange rate is fixed to one.
    ///
    pub fn get_stored_exchange_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStoredExchangeRate")
            .original_result()
    }

    /// Returns a fixed exchange rate to one.
    ///
    pub fn get_exchange_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getExchangeRate")
            .original_result()
    }

    /// Returns the close factor, used to determine the maximum amount of a borrow that can be repaid during a liquidation.
    /// If not set, it returns the minimum allowed close factor.
    ///
    pub fn get_close_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCloseFactor")
            .original_result()
    }

    /// Returns the current liquidation incentive. If not set, it returns the minimum allowed liquidation incentive, which is
    /// compliant with the default protocol seize share of 0% and the maximum collateral factor of 90%.
    ///
    pub fn get_liquidation_incentive(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationIncentive")
            .original_result()
    }

    /// Updates the account discount rate.
    ///
    /// # Arguments:
    ///
    /// - `opt_account` - The account's address. If not provided, the caller is used.
    ///
    pub fn update_account_discount_rate<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAccountDiscountRate")
            .argument(&opt_account)
            .original_result()
    }

    /// Activates the USH Money Market.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn activate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("activate")
            .original_result()
    }

    /// Finalizes the Market. From this point onwards it can be removed from the Controller as an Observer.
    ///
    pub fn finalize(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("finalize")
            .original_result()
    }

    /// Updates the Staking smart contract address.
    ///
    /// # Arguments:
    ///
    /// - `staking_sc` - The Staking smart contract address.
    ///
    pub fn set_staking_contract<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        staking_sc: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStakingContract")
            .argument(&staking_sc)
            .original_result()
    }

    /// Updates the stake factor, i.e. the portion of the reserves that is used as staking rewards.
    ///
    /// # Arguments:
    ///
    /// - `stake_factor` - The new reserve factor in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The new stake factor must not exceed the maximum allowed.
    ///
    pub fn set_stake_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        stake_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStakeFactor")
            .argument(&stake_factor)
            .original_result()
    }

    /// Updates the close factor used at liquidations.
    ///
    /// # Arguments:
    ///
    /// - `close_factor` - The new close factor in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_close_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        close_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCloseFactor")
            .argument(&close_factor)
            .original_result()
    }

    /// Updates the liquidation incentive for liquidations.
    ///
    /// # Arguments
    ///
    /// - `liquidation_incentive` - The new liquidation incentive in wad.
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - the new liquidation incentive should not be less than the amount that would yield losses for liquidators
    /// - the new liquidation incentive should be less than `1 / eff_ltv`, which is conservatively assumed to be `1 /
    ///   max_ltv`. Otherwise, there won't be a Risky region.
    ///
    pub fn set_liquidation_incentive<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        liquidation_incentive: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidationIncentive")
            .argument(&liquidation_incentive)
            .original_result()
    }

    /// Updates the protocol seize share, i.e. the portion of the seized amount that is kept by the protocol.
    ///
    /// # Arguments
    ///
    /// - `protocol_seize_share` - The new protocol seize share in wad.
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - the new protocol seize share cannot exceed the amount that would yield losses for liquidators
    ///
    pub fn set_protocol_seize_share<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        protocol_seize_share: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setProtocolSeizeShare")
            .argument(&protocol_seize_share)
            .original_result()
    }

    /// Updates the borrow rate.
    ///
    /// # Arguments
    ///
    /// - `borrow_apr` - The new borrow APR in wad.
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - the borrow rate cannot increase nor decrease too much
    /// - there is a time delay to increase the borrow rate
    /// - the borrow rate cannot be set to zero
    ///
    pub fn set_borrow_apr<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        borrow_apr: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBorrowApr")
            .argument(&borrow_apr)
            .original_result()
    }

    /// Updates the Discount Rate Model.
    ///
    /// # Arguments
    ///
    /// - `discount_rate_model` - The Discount Rate Model smart contract address.
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - the provided address must be a valid Discount Rate Model smart contract
    ///
    pub fn set_discount_rate_model<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        discount_rate_model: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setDiscountRateModel")
            .argument(&discount_rate_model)
            .original_result()
    }

    /// Withdraws an specified amount of USH from the money market reserves (revenue part) to the admin account.
    ///
    /// # Arguments:
    ///
    /// - `opt_ush_amount` - The amount of USH to withdraw. If not provided, the entire revenue is withdrawn.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The USH amount is directed to the admin account.
    ///
    pub fn reduce_reserves<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_ush_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reduceReserves")
            .argument(&opt_ush_amount)
            .original_result()
    }

    /// Updates the accrual time threshold.
    ///
    /// # Arguments:
    ///
    /// - `accrual_time_threshold` - The new accrual time threshold in seconds.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_accrual_time_threshold<
        Arg0: ProxyArg<u64>,
    >(
        self,
        accrual_time_threshold: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAccrualTimeThreshold")
            .argument(&accrual_time_threshold)
            .original_result()
    }

    /// Whitelists a trusted minter contract, i.e. a contract that can mint and enter market in the name of someone else.
    ///
    /// # Arguments:
    ///
    /// - `trusted_minter` - the new trusted minter to whitelist
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - `trusted_minter` must be a trusted smart contract
    /// - `trusted_minter` must not be already trusted
    ///
    pub fn add_trusted_minter<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        trusted_minter: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addTrustedMinter")
            .argument(&trusted_minter)
            .original_result()
    }

    /// Removes a trusted minter contract address from the whitelist of trusted minters contracts.
    ///
    /// # Arguments:
    ///
    /// - `trusted_minter` - the trusted minter to remove
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - `trusted_minter` must has been already trusted
    ///
    pub fn remove_trusted_minter<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        trusted_minter: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeTrustedMinter")
            .argument(&trusted_minter)
            .original_result()
    }

    /// Liquidate a risky borrower by taking her Hatom's tokens deposited as collateral at a specified money market.
    ///
    /// # Arguments:
    ///
    /// - `borrower` - The account to be liquidated.
    /// - `collateral_market ` - The money market in which to seize collateral from the borrower.
    /// - `opt_min_tokens` - The minimum amount of tokens to be seized from the borrower.
    ///
    pub fn liquidate_borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        borrower: Arg0,
        collateral_market: Arg1,
        opt_min_tokens: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue2<EsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("liquidateBorrow")
            .argument(&borrower)
            .argument(&collateral_market)
            .argument(&opt_min_tokens)
            .original_result()
    }

    /// Mints Hatom USH and enters the market in a single transaction.
    ///
    /// # Notes:
    ///
    /// - Must be paid with USH.
    ///
    pub fn mint_and_enter_market<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_account: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mintAndEnterMarket")
            .argument(&opt_account)
            .original_result()
    }

    /// This endpoint is called by the Controller smart contract whenever an account changes its collateral.
    ///
    /// # Arguments:
    ///
    /// - `account`: The account address.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the Controller smart contract.
    ///
    pub fn on_market_change<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("onMarketChange")
            .argument(&account)
            .original_result()
    }

    /// Exchanges paid Hatom USH tokens for USH.
    ///
    /// # Arguments:
    ///
    /// - `opt_ush_amount` - An optional amount of USH to receive back in exchange for the paid Hatom USH.
    ///
    pub fn redeem<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_ush_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue2<EgldOrEsdtTokenPayment<Env::Api>, EsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("redeem")
            .argument(&opt_ush_amount)
            .original_result()
    }

    /// Repays an outstanding USH borrow to the money market.
    ///
    /// # Arguments:
    ///
    /// - `opt_borrower` - An optional borrower address. Otherwise, caller is assumed to be the borrower.
    ///
    /// Notes:
    ///
    /// - The repayment amount can be higher than the outstanding borrow. In such case, the remainder is returned.
    ///
    pub fn repay_borrow<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_borrower: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("repayBorrow")
            .argument(&opt_borrower)
            .original_result()
    }

    /// Handler for `seize_internal` via smart contract to smart contract calls.
    ///
    /// # Arguments:
    ///
    /// - `liquidator` - The account retrieving the seized collateral.
    /// - `borrower` - The account having collateral seized.
    /// - `tokens_to_seize` - The tokens to seize.
    ///
    pub fn seize<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        liquidator: Arg0,
        borrower: Arg1,
        tokens_to_seize: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("seize")
            .argument(&liquidator)
            .argument(&borrower)
            .argument(&tokens_to_seize)
            .original_result()
    }

    /// Claims staking rewards from the staking contract.
    ///
    pub fn claim_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimStakingRewards")
            .original_result()
    }

    /// Stores the smart contract state.
    pub fn state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getState")
            .original_result()
    }

    /// Stores the USH Minter address.
    pub fn ush_minter(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshMinter")
            .original_result()
    }

    /// Stores the USH token identifier.
    pub fn ush_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshId")
            .original_result()
    }

    /// Stores the HUSH token identifier.
    pub fn hush_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getHushId")
            .original_result()
    }

    /// Stores whether HUSH is being issued or not.
    pub fn ongoing_issuance(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getOngoingIssuance")
            .original_result()
    }

    /// Stores the borrow snapshot for a given borrower account.
    pub fn account_borrow_snapshot<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        borrower: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, AccountSnapshot<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountBorrowSnapshot")
            .argument(&borrower)
            .original_result()
    }

    /// Stores the account's principal.
    pub fn account_principal<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        borrower: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPrincipal")
            .argument(&borrower)
            .original_result()
    }

    /// Stores the total amount of outstanding borrows up to the last accrue of interest.
    pub fn total_borrows(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalBorrows")
            .original_result()
    }

    pub fn effective_borrows(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEffectiveBorrows")
            .original_result()
    }

    pub fn total_principal(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalPrincipal")
            .original_result()
    }

    /// Stores the current amount of reserves.
    pub fn total_reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalReserves")
            .original_result()
    }

    /// Stores the total amount of staking rewards.
    pub fn staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingRewards")
            .original_result()
    }

    /// Stores the amount of historical staking rewards.
    pub fn historical_staking_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getHistoricalStakingRewards")
            .original_result()
    }

    /// Stores the amount of protocol revenue.
    pub fn revenue(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRevenue")
            .original_result()
    }

    /// Stores the total supply of the token.
    pub fn total_supply(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalSupply")
            .original_result()
    }

    /// Stores whether USH can be used as collateral or not.
    pub fn eligible_as_collateral(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("eligibleAsCollateral")
            .original_result()
    }

    /// Stores the borrow rate per second.
    pub fn borrow_rate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowRate")
            .original_result()
    }

    /// Stores the last time the borrow rate was updated.
    pub fn last_borrow_rate_update(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastBorrowRateUpdate")
            .original_result()
    }

    /// Stores the staking factor used to calculate staking rewards.
    pub fn stake_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakeFactor")
            .original_result()
    }

    /// Stores the timestamp of the last accrual.
    pub fn accrual_timestamp(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccrualTimestamp")
            .original_result()
    }

    /// Stores the Staking Module smart contract address.
    pub fn staking_sc(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingSc")
            .original_result()
    }

    /// Stores the address of the Discount Rate Model.
    pub fn discount_rate_model(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getDiscountRateModel")
            .original_result()
    }

    /// Stores the current protocol seize share.
    pub fn protocol_seize_share(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getProtocolSeizeShare")
            .original_result()
    }

    /// Stores the accrual time threshold.
    pub fn accrual_time_threshold(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccrualTimeThreshold")
            .original_result()
    }

    /// Stores the set of addresses with borrow.
    pub fn market_borrowers(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMarketBorrowers")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq)]
pub enum State {
    Empty,
    Active,
    Inactive,
    Finalized,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct AccountSnapshot<Api>
where
    Api: ManagedTypeApi,
{
    pub borrow_amount: BigUint<Api>,
    pub borrow_index: BigUint<Api>,
    pub discount: BigUint<Api>,
}
