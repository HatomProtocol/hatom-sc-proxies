// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct RewardsBoosterProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for RewardsBoosterProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = RewardsBoosterProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        RewardsBoosterProxyMethods { wrapped_tx: tx }
    }
}

pub struct RewardsBoosterProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> RewardsBoosterProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the contract with essential parameters and an optional admin address.
    ///
    /// # Arguments:
    ///
    /// - `stake_token_id` - The token identifier for staking.
    /// - `controller` - The address for the Controller smart contract.
    /// - `staking_ratio_threshold` - The staking ratio threshold used for rewards penalties.
    /// - `cooldown_period` - The cooldown period before staked tokens can be claimed.
    /// - `opt_admin` - An optional admin address.
    ///
    /// Notes:
    ///
    /// - If the admin address is not provided, the admin will be set as the deployer.
    /// - If the contract is being deployed for the first time, all provided parameters will be set.
    /// - If the contract is being upgraded, no parameter will be overwritten.
    ///
    pub fn init<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<u64>,
        Arg4: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        stake_token_id: Arg0,
        controller: Arg1,
        staking_ratio_threshold: Arg2,
        cooldown_period: Arg3,
        opt_admin: Arg4,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&stake_token_id)
            .argument(&controller)
            .argument(&staking_ratio_threshold)
            .argument(&cooldown_period)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> RewardsBoosterProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> RewardsBoosterProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address.
    ///
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one.
    ///
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address.
    ///
    /// # Arguments:
    ///
    /// - `new_pending_admin` - The new pending admin address.
    ///
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint.
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// A utility function to highlight that this smart contract is a Rewards Booster.
    ///
    pub fn is_rewards_booster(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isRewardsBooster")
            .original_result()
    }

    /// A utility function that returns the version of the smart contract.
    ///
    pub fn get_version(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getVersion")
            .original_result()
    }

    /// A utility function that returns whether the smart contract is a trusted staker.
    ///
    pub fn is_trusted_staker(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isTrustedStaker")
            .original_result()
    }

    /// Checks whether the current state of the smart contract is active.
    ///
    pub fn is_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isActive")
            .original_result()
    }

    /// Checks whether the current state of the smart contract is finalized.
    ///
    pub fn is_finalized(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isFinalized")
            .original_result()
    }

    /// Retrieves the total amount of collateral tokens of a given money market considering only the accounts that have
    /// an stake in such market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market for which to retrieve the total collateral tokens.
    ///
    pub fn get_stored_total_collateral_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStoredTotalCollateralTokens")
            .argument(&money_market)
            .original_result()
    }

    /// Retrieves the amount of collateral tokens of a given money market and account. It's value will be correct once
    /// the account has initialized its collateral in this smart contract and while this smart contract is a market
    /// observer at the Controller.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The address of the money market.
    /// - `account`: The account for which to retrieve the collateral tokens.
    ///
    pub fn get_stored_account_collateral_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStoredAccountCollateralTokens")
            .argument(&money_market)
            .argument(&account)
            .original_result()
    }

    /// Retrieves the accrued rewards for a given account and rewards token ID.
    ///
    /// # Arguments:
    ///
    /// - `account` - The account for which to retrieve the accrued rewards.
    /// - `rewards_token_id` - The ID of the rewards token for which to retrieve the accrued rewards.
    ///
    pub fn get_account_accrued_rewards<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        account: Arg0,
        rewards_token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountAccruedRewards")
            .argument(&account)
            .argument(&rewards_token_id)
            .original_result()
    }

    /// Retrieves the staked amount for a given account between all money markets.
    ///
    /// # Arguments:
    ///
    /// - `account`: The account for which to retrieve the staked amount.
    ///
    pub fn get_account_stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountStake")
            .argument(&account)
            .original_result()
    }

    /// Retrieves the staked amount for a given account in a specific money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The address of the money market.
    /// - `account`: The account for which to retrieve the staked amount.
    ///
    pub fn get_account_market_stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountMarketStake")
            .argument(&money_market)
            .argument(&account)
            .original_result()
    }

    /// Retrieves the total staked amount across all accounts and money markets.
    ///
    pub fn get_total_stake(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalStake")
            .original_result()
    }

    /// Retrieves the cooldown period for unstaking.
    ///
    pub fn get_cooldown_period(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCooldownPeriod")
            .original_result()
    }

    /// Retrieves the price integral coordinates for a given money market. The price integral is defined as the integral
    /// of the quotient between the stake token price and the collateral token price, both in the same numeraire. Also,
    /// this value is in wad units.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The address of the money market.
    ///
    pub fn get_price_integral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceIntegral")
            .argument(&money_market)
            .original_result()
    }

    /// Retrieves the price integral coordinates for a given money market and account. The price integral is defined as
    /// the integral of the quotient between the stake token price and the collateral token price, both in the same
    /// numeraire. Also, this value is in wad units. If the account has not been initialized, the function will return
    /// the price integral of the market.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The address of the money market.
    /// - `account`: The account for which to retrieve the sanction index.
    ///
    pub fn get_account_price_integral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPriceIntegral")
            .argument(&money_market)
            .argument(&account)
            .original_result()
    }

    /// Retrieves the total undistributed or penalized rewards for a given token identifier.
    ///
    /// # Arguments:
    ///
    /// - `rewards_token_id`: The token identifier of the rewards token.
    ///
    pub fn get_penalized_rewards<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        rewards_token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPenalizedRewards")
            .argument(&rewards_token_id)
            .original_result()
    }

    /// Retrieves the last fetched exchange rate for a given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The address of the money market.
    ///
    pub fn get_last_exchange_rate<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastExchangeRate")
            .argument(&money_market)
            .original_result()
    }

    /// Retrieves the last fetched underlying price for a given money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The address of the money market.
    ///
    pub fn get_last_underlying_price<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastUnderlyingPrice")
            .argument(&money_market)
            .original_result()
    }

    /// Retrieves a reliable exchange rate from the money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The address of the money market.
    ///
    pub fn get_reliable_exchange_rate<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReliableExchangeRate")
            .argument(&money_market)
            .original_result()
    }

    /// Retrieves a reliable price from a given money market underlying.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The address of the money market.
    ///
    pub fn get_reliable_underlying_price<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReliableUnderlyingPrice")
            .argument(&money_market)
            .original_result()
    }

    /// Activates the Booster. The activation can only occur if this smart contract is set as a market observer on
    /// the Controller.
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    ///
    pub fn activate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("activate")
            .original_result()
    }

    /// Deactivates the Booster.
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    ///
    pub fn deactivate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("deactivate")
            .original_result()
    }

    /// Finalizes the Booster. From this point onwards it can be deprecated from the Controller.
    ///
    pub fn finalize(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("finalize")
            .original_result()
    }

    /// Sets the rebalance method, which either forces all users to have their stakes balanced with the default weights
    /// or allows them to have their stakes balanced with custom weights.
    ///
    /// # Arguments:
    ///
    /// - `rebalance_method` - The desired rebalance method, either `Default` or `Custom`.
    ///
    pub fn set_rebalance_method<
        Arg0: ProxyArg<RebalanceMethod>,
    >(
        self,
        rebalance_method: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRebalanceMethod")
            .argument(&rebalance_method)
            .original_result()
    }

    /// Updates the pricing Oracle smart contract address.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The Oracle's address will be fetched from the Controller.
    ///
    pub fn update_price_oracle(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updatePriceOracle")
            .original_result()
    }

    /// Sets the cooldown period for the protocol.
    ///
    /// # Arguments:
    ///
    /// - `cooldown_period` - The desired cooldown period in seconds.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_cooldown_period<
        Arg0: ProxyArg<u64>,
    >(
        self,
        cooldown_period: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCooldownPeriod")
            .argument(&cooldown_period)
            .original_result()
    }

    /// Sets the staking ratio threshold for the protocol.
    ///
    /// # Arguments:
    ///
    /// - `staking_ratio_threshold` - The desired staking ratio threshold value.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_staking_ratio_threshold<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        staking_ratio_threshold: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStakingRatioThreshold")
            .argument(&staking_ratio_threshold)
            .original_result()
    }

    /// Sets the price time threshold, which is considered when fetching new exchange rates from Money Markets or prices
    /// from the Oracle.
    ///
    /// # Arguments:
    ///
    /// - `price_time_threshold` - The desired price time threshold value.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - If the threshold equals to zero, the price will be fetched every time, even in the same block.
    ///
    pub fn set_price_time_threshold<
        Arg0: ProxyArg<u64>,
    >(
        self,
        price_time_threshold: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPriceTimeThreshold")
            .argument(&price_time_threshold)
            .original_result()
    }

    /// Sets the Rewards Manager of the protocol.
    ///
    /// # Arguments:
    ///
    /// - `rewards_manager` - The address of the new Rewards Manager.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_rewards_manager<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        rewards_manager: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRewardsManager")
            .argument(&rewards_manager)
            .original_result()
    }

    /// Sets the maximum amount of rewards batches per money market.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `new_max_rewards_batches` - The new maximum amount of rewards batches.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provided address must be a whitelisted money market.
    ///
    pub fn set_max_rewards_batches<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        money_market: Arg0,
        max_rewards_batches: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxRewardsBatches")
            .argument(&money_market)
            .argument(&max_rewards_batches)
            .original_result()
    }

    /// Sets the maximum slippage allowed for configuration swaps.
    ///
    /// # Arguments:
    ///
    /// - `new_max_slippage` - The new maximum slippage allowed.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_max_slippage<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        max_slippage: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxSlippage")
            .argument(&max_slippage)
            .original_result()
    }

    /// Adds a rewards batch to the specified money market. EGLD or ESDT tokens are supported.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `period` - The period of time in seconds in which rewards are distributed.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - The provided address must be whitelisted money market.
    /// - Should be paid with the rewards token.
    ///
    pub fn set_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        money_market: Arg0,
        period: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, usize> {
        self.wrapped_tx
            .raw_call("setRewardsBatch")
            .argument(&money_market)
            .argument(&period)
            .original_result()
    }

    /// Adds an amount of reward token to an existing rewards batch maintaining the same speed.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `batch_id` - The rewards batch identifier.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn add_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addRewardsBatch")
            .argument(&money_market)
            .argument(&batch_id)
            .original_result()
    }

    /// Cancel a specified rewards batch. Remaining tokens are sent back to a beneficiary.
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `batch_id` - The rewards batch identifier.
    /// - `opt_to` - The beneficiary address for the remaining tokens (optional).
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - The caller is selected if no beneficiary is given.
    ///
    pub fn cancel_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        opt_to: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelRewardsBatch")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&opt_to)
            .original_result()
    }

    /// Removes a specified rewards batch from the array of rewards batches iff it has been fully distributed.
    ///
    /// # Arguments
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `batch_id` - The rewards batch identifier.
    ///
    /// # Notes
    ///
    /// - Can be called by anyone.
    /// - Takes into consideration possible rounding errors but it is conservative.
    ///
    pub fn remove_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeRewardsBatch")
            .argument(&money_market)
            .argument(&batch_id)
            .original_result()
    }

    /// Removes a specified rewards batch from the array of rewards batches iff it has been fully distributed within a given
    /// tolerance amount.
    ///
    /// # Arguments
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `batch_id` - The rewards batch identifier.
    /// - `tolerance` - The tolerance in wad, such that 1 wad = 100%.
    ///
    /// # Notes
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn admin_remove_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        tolerance: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("adminRemoveRewardsBatch")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&tolerance)
            .original_result()
    }

    /// Updates a given rewards batch based on a new speed. The new speed of rewards also changes the remaining distribution
    /// time period.
    ///
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `batch_id` - The rewards batch identifier.
    /// - `new_speed` - The new speed of rewards in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn update_rewards_batch_speed<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        new_speed: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRewardsBatchSpeed")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&new_speed)
            .original_result()
    }

    /// Updates a given rewards batch based on a new period. The new period also changes the speed of rewards.
    ///
    ///
    /// # Arguments:
    ///
    /// - `money_market` - The address of the money market smart contract.
    /// - `batch_id` - The rewards batch identifier.
    /// - `new_dt` - The new period.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn update_rewards_batch_remaining_period<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        new_dt: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRewardsBatchRemainingPeriod")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&new_dt)
            .original_result()
    }

    /// Adds support for boosting rewards batches by converting the rewards batch tokens into Hatom's governance tokens
    /// with a premium.
    ///
    /// # Arguments:
    ///
    /// - `egld_wrapper` - the address of the EGLD wrapper smart contract
    /// - `router` - the address of the router smart contract
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn support_rewards_batch_boosting<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        egld_wrapper: Arg0,
        router: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportRewardsBatchBoosting")
            .argument(&egld_wrapper)
            .argument(&router)
            .original_result()
    }

    /// Enables support for boosting rewards batches.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn enable_rewards_batch_boosting(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("enableRewardsBatchBoosting")
            .original_result()
    }

    /// Disables support for boosting rewards batches.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn disable_rewards_batch_boosting(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("disableRewardsBatchBoosting")
            .original_result()
    }

    /// Boosts the rewards of a given rewards token by converting the rewards tokens into Hatom's governance token with
    /// a premium.
    ///
    /// # Arguments:
    ///
    /// - `premium` - the premium in wad, such that 1 wad = 100%.
    /// - `fwd_swap_amount` - the amount of tokens to swap.
    /// - `fwd_swap_path` - the swap path to convert the rewards batch tokens into Hatom's governance tokens.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - If rewards token is EGLD, swaps will add a EGLD => WEGLD step first. Also, the swap path needs to use the
    ///   WEGLD token identifier.
    ///
    pub fn boost_rewards<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedVec<Env::Api, SwapStep<Env::Api>>>,
    >(
        self,
        premium: Arg0,
        fwd_swap_amount: Arg1,
        fwd_swap_path: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("boostRewards")
            .argument(&premium)
            .argument(&fwd_swap_amount)
            .argument(&fwd_swap_path)
            .original_result()
    }

    /// Updates the premium of a given booster and, if a payment is provided, adds it to the booster's amount.
    ///
    /// # Arguments:
    ///
    /// - `rewards_token_id` - the rewards token identifier for which we wish to update its booster.
    /// - `premium` - the premium in wad, such that 1 wad = 100%.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - Cannot change the swap path. That requires canceling the booster and creating a new one.
    ///
    pub fn update_booster<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        rewards_token_id: Arg0,
        premium: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("updateBooster")
            .argument(&rewards_token_id)
            .argument(&premium)
            .original_result()
    }

    /// Cancels a given booster and sends the remaining tokens back to the caller.
    ///
    /// # Arguments:
    ///
    /// - `rewards_token_id` - the rewards token identifier for which we wish to cancel its booster.
    /// - `opt_to` - the beneficiary address for the remaining tokens (optional).
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn cancel_booster<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        rewards_token_id: Arg0,
        opt_to: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelBooster")
            .argument(&rewards_token_id)
            .argument(&opt_to)
            .original_result()
    }

    /// Withdraws the undistributed or penalized rewards.
    ///
    /// # Arguments:
    ///
    /// - `token_id` - The rewards token identifier.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - Withdraws the total undistributed amounts for the specified token ID or EGLD and sends them to the admin
    ///   address.
    ///
    pub fn withdraw_penalized_rewards<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        rewards_token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdrawnPenalizedRewards")
            .argument(&rewards_token_id)
            .original_result()
    }

    /// Sets the Migration Manager of the protocol.
    ///
    /// # Arguments:
    ///
    /// - `migration_manager` - The address of the new Migration Manager.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_migration_manager<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        migration_manager: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMigrationManager")
            .argument(&migration_manager)
            .original_result()
    }

    /// Enables the migration process.
    ///
    /// # Arguments:
    ///
    /// - `booster_v2` - The address of the new Booster.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - Requires the state to be finalized.
    /// - The new Booster must be the booster observer at the Controller.
    /// - The new Booster must have the same stake token as this Booster.
    /// - This Booster must have been already trusted at the new Booster.
    ///
    pub fn enable_migration<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        booster_v2: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("enableMigration")
            .argument(&booster_v2)
            .original_result()
    }

    /// Initializes the account collateral for all current and future money markets belonging to the lending protocol.
    /// Once an account collateral is tracked, it will be tracked forever or until this smart contract is not anymore a
    /// market observer.
    ///
    pub fn init_account_collateral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("initAccountCollateral")
            .argument(&account)
            .original_result()
    }

    /// This endpoint is called by the Controller smart contract whenever an account changes its collateral.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The address of the money market, which reflects the type of collateral.
    /// - `account`: The address of the account.
    /// - `tokens`: The new total amount of collateral tokens for the account.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the Controller smart contract.
    ///
    pub fn on_market_change<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        account: Arg1,
        tokens: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("onMarketChange")
            .argument(&money_market)
            .argument(&account)
            .argument(&tokens)
            .original_result()
    }

    /// Performs a price integration for all whitelisted money markets. The actual integrated variable is the quotient
    /// between the stake token price and the collateral price. This endpoint can be called by anyone and the integral
    /// will be more reliable the more often it is called.
    ///
    /// # Arguments:
    ///
    /// - `money_markets`: An array of money market addresses.
    ///
    pub fn integrate_prices<
        Arg0: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        money_markets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("integratePrices")
            .argument(&money_markets)
            .original_result()
    }

    /// Returns the account penalty factor for a given money market and account. The penalty factor is a value between 0
    /// and 1 that represents the percentage of rewards the account is not eligible to receive. The penalty factor is
    /// calculated based on the account's staking ratio (its stake value divided by its collateral value on a money
    /// market basis) and a given staking ratio threshold.
    ///
    /// # Arguments:
    ///
    /// - `money_market`: The money market address.
    /// - `account`: The account address.
    ///
    pub fn get_account_penalty_factor<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPenaltyFactor")
            .argument(&money_market)
            .argument(&account)
            .original_result()
    }

    /// Rebalances the portfolio of an account by updating its stakes on each money markets. The new portfolio can be
    /// defined either by explicit amounts for each money market or by using the default portfolio, which is a portfolio
    /// that is automatically calculated based on the account's collateral on each money market.
    ///
    /// # Arguments:
    ///
    /// - `markets`: An array of market addresses.
    /// - `amounts`: An array of stake amounts corresponding to the markets vector.
    ///
    /// # Notes:
    ///
    /// - If the `markets` and `amounts` arrays are empty, the default portfolio will be used.
    ///
    pub fn rebalance_portfolio<
        Arg0: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg1: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
        Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        markets: Arg0,
        amounts: Arg1,
        opt_account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("rebalancePortfolio")
            .argument(&markets)
            .argument(&amounts)
            .argument(&opt_account)
            .original_result()
    }

    /// Computes the default portfolio for an account. The default portfolio is a portfolio that is automatically
    /// calculated based on the account's collateral on each money market and its total stake. The default portfolio is
    /// computed by calculating the percentage of collateral that each money market represents from the total collateral
    /// and then multiplying that percentage by the total stake.
    ///
    /// # Arguments:
    ///
    /// - `account`: The address of the account.
    ///
    pub fn default_portfolio<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (ManagedVec<Env::Api, ManagedAddress<Env::Api>>, ManagedVec<Env::Api, BigUint<Env::Api>>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("defaultPortfolio")
            .argument(&account)
            .original_result()
    }

    /// Updates the state of all rewards batches for the given money markets.
    ///
    /// # Arguments:
    ///
    /// - `money_markets`: An array of money market addresses.
    ///
    /// # Notes:
    ///
    /// - If no markets are provided, then all whitelisted money markets will be updated.
    ///
    pub fn update_rewards_batches_state<
        Arg0: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        money_markets: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRewardsBatchesState")
            .argument(&money_markets)
            .original_result()
    }

    /// Distributes all rewards from all rewards batches for the given money markets to the given account.
    ///
    /// # Arguments:
    ///
    /// - `money_markets`: An array of money market addresses.
    /// - `account`: The address of the account.
    ///
    /// # Notes:
    ///
    /// - If no markets are provided, then all whitelisted money markets will be used.
    ///
    pub fn distribute_account_rewards<
        Arg0: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_markets: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("distributeAccountRewards")
            .argument(&money_markets)
            .argument(&account)
            .original_result()
    }

    /// Distributes all rewards from all rewards batches for the given money markets to the given accounts.
    ///
    /// # Arguments:
    ///
    /// - `money_markets`: An array of money market addresses.
    /// - `account`: An array of account addresses.
    ///
    /// # Notes:
    ///
    /// - If no markets are provided, then all whitelisted money markets will be used.
    /// - If no accounts are provided, then only the caller will get his rewards distributed.
    ///
    pub fn distribute_rewards<
        Arg0: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg1: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        money_markets: Arg0,
        accounts: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("distributeRewards")
            .argument(&money_markets)
            .argument(&accounts)
            .original_result()
    }

    /// Sends all rewards from all rewards batches for the given money markets to the given account.
    ///
    /// # Arguments:
    ///
    /// - `boost`: Whether to boost the rewards or not.
    /// - `money_markets`: An array of money market addresses.
    /// - `accounts`: An array of account addresses.
    /// - `opt_min_boosted_rewards_out`: An optional minimum amount of boosted rewards out.
    ///
    /// # Notes:
    ///
    /// - If `boost` is enabled, then the rewards will be boosted using the rewards booster.
    /// - If no money markets are specified, then all whitelisted money markets will be used.
    /// - If no accounts are provided, then only the caller will claim his rewards.
    ///
    pub fn claim_rewards<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg2: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg3: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        boost: Arg0,
        money_markets: Arg1,
        accounts: Arg2,
        opt_min_boosted_rewards_out: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewards")
            .argument(&boost)
            .argument(&money_markets)
            .argument(&accounts)
            .argument(&opt_min_boosted_rewards_out)
            .original_result()
    }

    /// Sends all rewards from all rewards batches for the given money markets to the given account.
    ///
    /// # Arguments:
    ///
    /// - `boost`: Whether to boost the rewards or not.
    /// - `tokens`: An array of rewards tokens.
    /// - `money_markets`: An array of money market addresses in which the rewards distribution will be done.
    /// - `accounts`: An array of account addresses.
    /// - `opt_min_boosted_rewards_out`: An optional minimum amount of boosted rewards out.
    ///
    /// # Notes:
    ///
    /// - If `boost` is enabled, then the rewards will be boosted using the rewards booster.
    /// - If no money markets are specified, then all whitelisted money markets will be used.
    /// - If a provided money market does not have any batch for the rewards tokens, then it will be ignored.
    /// - If no accounts are provided, then only the caller will claim his rewards.
    ///
    pub fn claim_rewards_tokens<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<ManagedVec<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
        Arg2: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg3: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg4: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        boost: Arg0,
        tokens: Arg1,
        money_markets: Arg2,
        accounts: Arg3,
        opt_min_boosted_rewards_out: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewardsTokens")
            .argument(&boost)
            .argument(&tokens)
            .argument(&money_markets)
            .argument(&accounts)
            .argument(&opt_min_boosted_rewards_out)
            .original_result()
    }

    /// This endpoint allows users to stake tokens to start earning rewards. The user can specify the markets and their
    /// corresponding amounts to stake. On the contrary, if no markets and amounts are specified, a default algorithm
    /// based on the account collateral and current rewards batches will be used to determine the markets and amounts to
    /// stake.
    ///
    /// # Arguments:
    ///
    /// - `markets`: An array of market addresses to stake.
    /// - `amounts`: An array of amounts to stake for each respective money market specified in `markets`.
    ///
    pub fn stake<
        Arg0: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg1: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
    >(
        self,
        markets: Arg0,
        amounts: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("stake")
            .argument(&markets)
            .argument(&amounts)
            .original_result()
    }

    /// This endpoint allows users to unstake their staked tokens. This process will start a cooldown period after which
    /// the user can claim his tokens. The user can specify the markets and their corresponding amounts to unstake. On
    /// the contrary, if no markets and amounts are specified, a default algorithm based on the account collateral and
    /// current rewards batches will be used to determine the final state of the portfolio positions.
    ///
    /// # Arguments:
    ///
    /// - `unstaked_amount`: The amount of tokens the user wish to unstake.
    /// - `markets`: An array of market addresses to unstake from.
    /// - `amounts`: An array of amounts to unstake from each money market specified in `markets`.
    /// - `opt_max_cooldown_period` - The maximum accepted cooldown period for the claim.
    ///
    pub fn unstake<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg2: ProxyArg<ManagedVec<Env::Api, BigUint<Env::Api>>>,
        Arg3: ProxyArg<OptionalValue<u64>>,
    >(
        self,
        unstaked_amount: Arg0,
        markets: Arg1,
        amounts: Arg2,
        opt_max_cooldown_period: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unstake")
            .argument(&unstaked_amount)
            .argument(&markets)
            .argument(&amounts)
            .argument(&opt_max_cooldown_period)
            .original_result()
    }

    /// This endpoint allows users to unstake their staked tokens even if pricing is not operational. Users won't
    /// collect any rewards in such cases, given that there is no way to compute meaningful penalties.
    ///
    /// # Arguments:
    ///
    /// - `markets`: An array of market addresses to unstake from.
    /// - `opt_max_cooldown_period` - The maximum accepted cooldown period for the claim.
    ///
    pub fn emergency_unstake<
        Arg0: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg1: ProxyArg<OptionalValue<u64>>,
    >(
        self,
        markets: Arg0,
        opt_max_cooldown_period: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("emergencyUnstake")
            .argument(&markets)
            .argument(&opt_max_cooldown_period)
            .original_result()
    }

    /// This endpoint allows users to claim their unstaked tokens after the cooldown period has elapsed.
    ///
    /// # Arguments:
    ///
    /// - `claim_id`: The claim identifier.
    ///
    pub fn claim<
        Arg0: ProxyArg<usize>,
    >(
        self,
        claim_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claim")
            .argument(&claim_id)
            .original_result()
    }

    /// This endpoint allows users to claim their tokens coming from multiple unstakes after the cooldown period has
    /// elapsed for all of them.
    ///
    /// # Arguments:
    ///
    /// - `claim_ids`: An array of claim identifiers.
    ///
    pub fn claim_multiple<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, usize>>,
    >(
        self,
        claim_ids: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimMultiple")
            .argument(&claim_ids)
            .original_result()
    }

    /// This endpoint allows the account, admin or the migration manager to migrate the staking position of an account
    /// to a new booster.
    ///
    /// # Arguments:
    ///
    /// - `opt_account`: The account's address to migrate. If not provided, the caller will be used.
    ///
    /// # Notes:
    ///
    /// - Migrations should be enabled.
    ///
    pub fn migrate<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("migrate")
            .argument(&opt_account)
            .original_result()
    }

    /// The current state of the Booster module.
    pub fn state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getState")
            .original_result()
    }

    /// Stores the token ID for staking.
    pub fn stake_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakeTokenId")
            .original_result()
    }

    /// Stores the price oracle smart contract address.
    pub fn price_oracle(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceOracle")
            .original_result()
    }

    /// Stores the controller smart contract address.
    pub fn controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    /// Stores the rewards manager address.
    pub fn rewards_manager(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsManager")
            .original_result()
    }

    /// Stores the rewards manager address.
    pub fn migration_manager(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMigrationManager")
            .original_result()
    }

    /// Stores the rewards index for a given account and rewards token in the specified money market.
    pub fn account_batch_rewards_index<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountBatchRewardsIndex")
            .argument(&money_market)
            .argument(&batch_id)
            .argument(&account)
            .original_result()
    }

    /// Stores the ID of the next rewards batch in the specified money market.
    pub fn next_rewards_batch_id<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNextRewardsBatchId")
            .argument(&money_market)
            .original_result()
    }

    pub fn max_rewards_batches<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxRewardsBatches")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the maximum allowed slippage.
    pub fn max_slippage(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxSlippage")
            .original_result()
    }

    /// Stores the list of rewards batches in the specified money market.
    pub fn rewards_batches<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, RewardsBatch<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsBatches")
            .argument(&money_market)
            .original_result()
    }

    /// Stores the current position of a rewards batch in the specified money market at the corresponding VecMapper.
    pub fn rewards_batch_position<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        money_market: Arg0,
        batch_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsBatchPosition")
            .argument(&money_market)
            .argument(&batch_id)
            .original_result()
    }

    /// Stores staking ratio threshold.
    pub fn staking_ratio_threshold(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingRatioThreshold")
            .original_result()
    }

    /// Stores the account staking ratio threshold.
    pub fn account_staking_ratio_threshold<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountStakingRatioThreshold")
            .argument(&money_market)
            .argument(&account)
            .original_result()
    }

    /// Stores price time threshold.
    pub fn price_time_threshold(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceTimeThreshold")
            .original_result()
    }

    pub fn rebalance_method(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, RebalanceMethod> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRebalanceMethod")
            .original_result()
    }

    /// Stores the claim made by an account based on their claim ID.
    pub fn account_claims_by_id<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        account: Arg0,
        claim_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Claim<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountClaimsById")
            .argument(&account)
            .argument(&claim_id)
            .original_result()
    }

    /// Stores the next available claim ID for a particular account.
    pub fn next_claim_id<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNextClaimId")
            .argument(&account)
            .original_result()
    }

    /// Stores the rewards batch booster for a given rewards token identifier.
    pub fn rewards_booster<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, RewardsBooster<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsBooster")
            .argument(&token_id)
            .original_result()
    }

    /// Stores wrapped EGLD smart contract address.
    pub fn egld_wrapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldWrapper")
            .original_result()
    }

    /// Stores the token identifier of the wrapped EGLD token.
    pub fn wegld_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWegldId")
            .original_result()
    }

    /// Stores the xExchange Router address.
    pub fn router(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRouter")
            .original_result()
    }

    /// Stores the boosting state.
    pub fn boosting_state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBoostingState")
            .original_result()
    }

    /// Stores whether boosting is or not supported.
    pub fn rewards_batch_boosting_supported(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isRewardsBatchBoostingSupported")
            .original_result()
    }

    /// Stores the Booster v2 address.
    pub fn booster_v2(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBoosterV2")
            .original_result()
    }

    /// Stores the migration state.
    pub fn migration_state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMigrationState")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Eq, Copy, Clone, Debug)]
pub enum State {
    Inactive,
    Active,
    Finalized,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Eq, Copy, Clone, Debug)]
pub enum RebalanceMethod {
    Default,
    Custom,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct RewardsBatch<Api>
where
    Api: ManagedTypeApi,
{
    pub id: usize,
    pub money_market: ManagedAddress<Api>,
    pub token_id: EgldOrEsdtTokenIdentifier<Api>,
    pub amount: BigUint<Api>,
    pub distributed_amount: BigUint<Api>,
    pub speed: BigUint<Api>,
    pub index: BigUint<Api>,
    pub last_time: u64,
    pub end_time: u64,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone)]
pub struct Claim<Api>
where
    Api: ManagedTypeApi,
{
    pub id: usize,
    pub amount: BigUint<Api>,
    pub claim_timestamp: u64,
    pub claimed: bool,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct RewardsBooster<Api>
where
    Api: ManagedTypeApi,
{
    pub token_id: EgldOrEsdtTokenIdentifier<Api>,
    pub premium: BigUint<Api>,
    pub amount_left: BigUint<Api>,
    pub distributed_amount: BigUint<Api>,
    pub swap_path: ManagedVec<Api, SwapStep<Api>>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct SwapStep<Api>
where
    Api: ManagedTypeApi,
{
    pub pair_address: ManagedAddress<Api>,
    pub input_token_id: TokenIdentifier<Api>,
    pub output_token_id: TokenIdentifier<Api>,
}
