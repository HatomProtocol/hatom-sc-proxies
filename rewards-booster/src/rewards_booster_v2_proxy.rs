// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct RewardsBoosterV2Proxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for RewardsBoosterV2Proxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = RewardsBoosterV2ProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        RewardsBoosterV2ProxyMethods { wrapped_tx: tx }
    }
}

pub struct RewardsBoosterV2ProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> RewardsBoosterV2ProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        main_stake_token: Arg0,
        controller: Arg1,
        ush_staking: Arg2,
        egld_wrapper: Arg3,
        opt_admin: Arg4,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&main_stake_token)
            .argument(&controller)
            .argument(&ush_staking)
            .argument(&egld_wrapper)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> RewardsBoosterV2ProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> RewardsBoosterV2ProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// A utility function to highlight that this smart contract is a Rewards Booster.
    ///
    pub fn is_rewards_booster(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isRewardsBooster")
            .original_result()
    }

    /// A utility function to highlight that this smart contract is a Stake Module Observer.
    ///
    pub fn is_stake_observer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isStakeObserver")
            .original_result()
    }

    /// A utility function that returns the version of the smart contract.
    ///
    pub fn get_version(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u8> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getVersion")
            .original_result()
    }

    /// Returns the current admin address.
    ///
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one.
    ///
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address.
    ///
    /// # Arguments:
    ///
    /// - `new_pending_admin` - The new pending admin address.
    ///
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint.
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// Sets the Governance smart contract address. From this point onwards, the account's voting power will be
    /// considered.
    ///
    /// # Arguments:
    ///
    /// - `governance` - The address of the Governance smart contract.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_governance<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        governance: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setGovernance")
            .argument(&governance)
            .original_result()
    }

    pub fn controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    pub fn main_stake_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMainStakeTokenId")
            .original_result()
    }

    pub fn price_oracle(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceOracle")
            .original_result()
    }

    pub fn governance(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getGovernance")
            .original_result()
    }

    pub fn account_manager_deployer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountManagerDeployer")
            .original_result()
    }

    /// Sets the Router smart contract address, and the EGLD wrapper smart contract addresses.
    ///
    /// # Arguments:
    ///
    /// - `router` - the address of the router smart contract
    /// - `egld_wrapper` - the address of the EGLD wrapper smart contract
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - This function should be called before enabling boosting for any pool provider.
    ///
    pub fn set_router<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        router: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRouter")
            .argument(&router)
            .original_result()
    }

    pub fn xex_router(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getXexRouter")
            .original_result()
    }

    pub fn egld_wrapper(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getEgldWrapper")
            .original_result()
    }

    pub fn wegld_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWegldId")
            .original_result()
    }

    /// Sets the price time threshold, which is considered when fetching new exchange rates from Money Markets or prices
    /// from the Oracle or Price Providers.
    ///
    /// # Arguments:
    ///
    /// - `price_time_threshold` - The desired price time threshold value.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - If the threshold equals to zero, the price will be fetched every time, even in the same block.
    ///
    pub fn set_price_time_threshold<
        Arg0: ProxyArg<u64>,
    >(
        self,
        price_time_threshold: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPriceTimeThreshold")
            .argument(&price_time_threshold)
            .original_result()
    }

    /// Retrieves the token price using the specified pricing method.
    ///
    /// # Arguments:
    ///
    /// - `token` - Identifier of the token.
    /// - `method` - Method to use for pricing (`LastPrice` or `ReliablePrice`).
    ///
    /// # Notes:
    ///
    /// - When using `ReliablePrice`, the function checks if the last price is within the `price_time_threshold`. If so,
    ///   it returns the last price instead of fetching a new one.
    ///
    pub fn get_token_price<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<PricingMethod>,
    >(
        self,
        token: Arg0,
        method: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenPrice")
            .argument(&token)
            .argument(&method)
            .original_result()
    }

    pub fn get_token_fx<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        token: Arg0,
        nonce: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTokenFx")
            .argument(&token)
            .argument(&nonce)
            .original_result()
    }

    /// Retrieves the last recorded token price and timestamp. Returns a dummy value if no price exists.
    ///
    pub fn get_last_token_price<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastTokenPrice")
            .argument(&token)
            .original_result()
    }

    pub fn price_time_threshold(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceTimeThreshold")
            .original_result()
    }

    /// Adds support for an AshSwap LP token by registering its price provider. The LP token should not have been
    /// whitelisted before.
    ///
    /// # Arguments:
    ///
    /// - `liquidity_pool` - Address of the associated liquidity pool.
    /// - `underlying_token` - Identifier of the derivative token.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The token must not be already supported by any other price provider.
    /// - The token must be a valid token.
    ///
    pub fn support_ashswap_lp_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        liquidity_pool: Arg0,
        underlying_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportAshswapLpToken")
            .argument(&liquidity_pool)
            .argument(&underlying_token)
            .original_result()
    }

    /// Supports a new hToken with the hToken price provider. This will allow the HatomTokenProvider to provide
    /// prices for the given token.
    ///
    /// # Arguments
    ///
    /// - `money_market` - Address of the associated money market.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The token must not be already supported by any other price provider.
    /// - The token must be a valid token.
    ///
    pub fn support_hatom_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        money_market: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportHatomToken")
            .argument(&money_market)
            .original_result()
    }

    /// Sets the pricing Oracle smart contract address.
    ///
    /// # Arguments:
    ///
    /// - `new_price_oracle` - The address of the pricing oracle smart contract.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provided address must be a valid oracle smart contract.
    ///
    pub fn update_price_oracle(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updatePriceOracle")
            .original_result()
    }

    /// Supports a new stake token with the Oracle price provider. This will allow the Oracle to provide prices for
    /// the given token.
    ///
    /// # Arguments:
    ///
    /// - `token` - The token identifier of the stake token to support.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The token must not be already supported by any other price provider.
    /// - The token must be a valid token.
    ///
    pub fn support_oracle_token<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportOracleToken")
            .argument(&token)
            .original_result()
    }

    /// Support a new Mirror token with the Mirror price provider. This will allow the MirrorProvider to provide
    /// prices for the given token.
    ///
    /// # Arguments
    ///
    /// - `token` - Identifier of the token.
    /// - `farm_token` - Identifier of the mirror token.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The token must not be already supported by any other price provider.
    /// - The token must be a valid token.
    ///
    pub fn support_xex_staking_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        staking: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("supportXexStakingToken")
            .argument(&staking)
            .original_result()
    }

    /// Adds support for an xExchange LP token by registering its price provider.
    ///
    /// # Arguments:
    ///
    /// - `pair` - Address of the associated liquidity pool.
    /// - `underlying_token` - Identifier of the underlying token.
    /// - `whole_price` - Boolean indicating if the price should be multiplied by 2.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The token must not be already supported by any other price provider.
    /// - The token must be a valid token.
    ///
    pub fn support_xexchange_lp_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<bool>,
    >(
        self,
        pair: Arg0,
        underlying_token: Arg1,
        whole_price: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportXExchangeLpToken")
            .argument(&pair)
            .argument(&underlying_token)
            .argument(&whole_price)
            .original_result()
    }

    /// Support a new Mirror token with the Mirror price provider. This will allow the MirrorProvider to provide
    /// prices for the given token.
    ///
    /// # Arguments
    ///
    /// - `token` - Identifier of the token.
    /// - `farm_token` - Identifier of the mirror token.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The token must not be already supported by any other price provider.
    /// - The token must be a valid token.
    ///
    pub fn support_xex_farm_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        farm: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("supportXexFarmToken")
            .argument(&farm)
            .original_result()
    }

    /// Support a new Dual Farm token with the Dual Farm price provider. This will allow the DualFarmProvider to
    /// provide prices for the given token.
    ///
    /// # Arguments
    ///
    /// - `dual_farm` - Identifier of the Dual Farm token.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The token must not be already supported by any other price provider.
    /// - The token must be a valid token.
    ///
    pub fn support_xex_dual_farm_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        dual_farm: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("supportXexDualFarmToken")
            .argument(&dual_farm)
            .original_result()
    }

    pub fn whitelisted_providers(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedProviders")
            .original_result()
    }

    pub fn provider_data<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, PoolProviderData> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getProviderData")
            .argument(&provider)
            .original_result()
    }

    /// Handles changes in collateral for a specific account in a money market.
    ///
    /// This function is triggered when tokens are added or removed as collateral in the Controller. It ensures the
    /// caller is a valid controller provider, retrieves the token identifier from the Controller, constructs a
    /// `Pool` object, and calls `on_pool_change` to update the pool state.
    ///
    /// # Arguments
    ///
    /// - `money_market` - Address of the money market associated with the change.
    /// - `account` - Address of the account involved in the collateral change.
    /// - `amount_new` - The new collateral amount for the account.
    /// - `amount_old` - The old collateral amount for the account.
    ///
    pub fn on_market_change<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        money_market: Arg0,
        account: Arg1,
        new_tokens: Arg2,
        prev_tokens: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("onMarketChange")
            .argument(&money_market)
            .argument(&account)
            .argument(&new_tokens)
            .argument(&prev_tokens)
            .original_result()
    }

    /// Handles changes in staking for a specific token and account.
    ///
    /// Ensures the caller is a valid staking provider, constructs a `Pool` object, and calls `on_pool_change` to
    /// update the pool state.
    ///
    /// # Arguments
    ///
    /// - `token` - Identifier of the token whose staking status changed.
    /// - `account` - Address of the account with the staking change.
    /// - `amount_new` - New staking balance for the account.
    /// - `amount_old` - Old staking balance for the account.
    ///
    pub fn on_stake_change<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token: Arg0,
        account: Arg1,
        new_tokens: Arg2,
        prev_tokens: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("onStakeChange")
            .argument(&token)
            .argument(&account)
            .argument(&new_tokens)
            .argument(&prev_tokens)
            .original_result()
    }

    /// A utility function used by the Governance smart contract.
    ///
    pub fn is_trusted_contract(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isTrustedContract")
            .original_result()
    }

    /// Synchronizes the voting power for a list of accounts.
    ///
    /// # Arguments:
    ///
    /// - `accounts` - A list of managed addresses whose voting power needs to be synchronized. If empty, the caller's
    ///   address is used.
    ///
    /// # Notes:
    ///
    /// - If no accounts are provided, the caller's address will be used.
    /// - If accounts are provided, the function requires admin privileges to execute.
    ///
    pub fn sync_voting_power<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        accounts: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("syncVotingPower")
            .argument(&accounts)
            .original_result()
    }

    pub fn has_sync_voting_power<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("hasSyncVotingPower")
            .argument(&account)
            .original_result()
    }

    pub fn account_local_voting_power<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountLocalVotingPower")
            .argument(&account)
            .original_result()
    }

    pub fn global_account_stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        account: Arg0,
        stake_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getGlobalAccountStake")
            .argument(&account)
            .argument(&stake_token)
            .original_result()
    }

    /// Initializes a new pool provider in the smart contract.
    ///
    /// The provider is set up with the specified parameters, including the cooldown period, the maximum number
    /// of stakes per account, and the maximum number of reward batches per pool.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `cooldown_period` - The cooldown period (in seconds) that an account must wait between unstaking and a
    ///   successful claim.
    /// - `max_account_stakes` - The maximum number of stakes an account can have.
    /// - `max_batches` - The maximum number of reward batches a pool can have.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - Pools and stakes for this provider are added in a separate transaction.
    /// - The booster should not be finalized.
    ///
    pub fn initialize_provider<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<usize>,
        Arg3: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        cooldown_period: Arg1,
        max_account_stakes: Arg2,
        max_batches: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("initializeProvider")
            .argument(&provider)
            .argument(&cooldown_period)
            .argument(&max_account_stakes)
            .argument(&max_batches)
            .original_result()
    }

    /// Activates a given pool provider. Once activated, users can start interacting with it.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provider must exist and be in an Inactive state.
    /// - Finalized providers cannot be reactivated.
    ///
    pub fn activate_provider<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("activateProvider")
            .argument(&provider)
            .original_result()
    }

    /// Finalizes a given pool provider. Once finalized, the only interactions allowed are unstaking and claiming rewards.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provider must exist and be in an Active state.
    /// - Once finalized, the provider cannot be reactivated.
    /// - If the provider has pools with reward batches, all rewards must be fully distributed before finalization.
    ///
    pub fn finalize_provider<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("finalizeProvider")
            .argument(&provider)
            .original_result()
    }

    /// Supports a new stake for a given program. The stake token must have a valid Price Provider and it must be
    /// working properly this means that it must consume gas within the expected limits. The stake token is added to the
    /// whitelist and its price is integrated.
    ///
    /// # Arguments:
    ///
    /// - `stake_token` - The stake token identifier.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The stake token must not be already whitelisted.
    ///
    pub fn support_stake_token<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        stake_token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportStakeToken")
            .argument(&stake_token)
            .original_result()
    }

    /// Adds support for a new pool within a given pool provider.
    ///
    /// The pool must be valid and exist within the specified pool provider. Once supported, the pool is added
    /// to the whitelist and its price is integrated using the Reliable Price method. Additionally, the staking
    /// ratio threshold and base rewards ratio are set.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `pool_token` - The identifier of the pool token.
    /// - `staking_ratio_threshold` - The staking ratio threshold.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The pool must exist within the specified pool provider.
    /// - The pool must not already be whitelisted in the pool provider.
    ///
    pub fn support_pool_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        staking_ratio_threshold: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportPoolToken")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&staking_ratio_threshold)
            .original_result()
    }

    /// Sets the sanction threshold for the pool within a given pool provider.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `pool` - The pool identifier of the pool.
    /// - `staking_ratio_threshold` - The desired sanction threshold value.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_staking_ratio_threshold<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        staking_ratio_threshold: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setStakingRatioThreshold")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&staking_ratio_threshold)
            .original_result()
    }

    /// Sets the cooldown period for a given program, defining the time that must elapse between unstaking and a
    /// successful claim.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `cooldown_period` - The desired cooldown period in seconds.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_cooldown_period<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        provider: Arg0,
        cooldown_period: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCooldownPeriod")
            .argument(&provider)
            .argument(&cooldown_period)
            .original_result()
    }

    /// Sets the maximum number of stakes per account within a given pool provider.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `max_account_stakes` - The new maximum number of stakes per account.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_max_account_stakes<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        max_account_stakes: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxAccountStakes")
            .argument(&provider)
            .argument(&max_account_stakes)
            .original_result()
    }

    /// Whitelists a trusted staker, i.e. an account or contract that can stake on behalf of someone else.
    ///
    /// # Arguments:
    ///
    /// - `trusted_staker` - the new trusted staker to whitelist
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - `trusted_staker` must not be already trusted
    ///
    pub fn add_trusted_staker<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        trusted_staker: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addTrustedStaker")
            .argument(&trusted_staker)
            .original_result()
    }

    /// Removes a trusted staker address from the whitelist of trusted stakers.
    ///
    /// # Arguments:
    ///
    /// - `trusted_staker` - the trusted staker to remove
    ///
    /// # Notes
    ///
    /// - can only be called by the admin
    /// - `trusted_staker` must has been already trusted
    ///
    pub fn remove_trusted_staker<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        trusted_staker: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeTrustedStaker")
            .argument(&trusted_staker)
            .original_result()
    }

    /// Sets the maximum amount of rewards batches per pool within a given pool provider.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `max_batches` - The new maximum amount of rewards batches.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - The provided address must be a whitelisted provider.
    ///
    pub fn set_max_batches<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        max_batches: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxBatches")
            .argument(&provider)
            .argument(&max_batches)
            .original_result()
    }

    /// Sets the Rewards Manager of the Rewards Booster.
    ///
    /// # Arguments:
    ///
    /// - `rewards_manager` - The address of the new Rewards Manager.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn set_rewards_manager<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        rewards_manager: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRewardsManager")
            .argument(&rewards_manager)
            .original_result()
    }

    /// Adds a rewards batch to the specified Pool (given by a provider and a pool token). EGLD or ESDT tokens are
    /// supported.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `pool_token` - The identifier of the pool.
    /// - `period` - The period of time in seconds in which rewards are distributed.
    /// - `is_extra` - A flag indicating if the rewards batch is extra or not.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - The provided pool must be whitelisted.
    /// - Should be paid with the rewards token.
    ///
    pub fn set_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<RewardsBatchType>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        period: Arg2,
        batch_type: Arg3,
    ) -> TxTypedCall<Env, From, To, (), Gas, usize> {
        self.wrapped_tx
            .raw_call("setRewardsBatch")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&period)
            .argument(&batch_type)
            .original_result()
    }

    /// Adds an amount of reward token to an existing rewards batch maintaining the same speed.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `pool` - The pool identifier of the pool.
    /// - `batch` - The rewards batch identifier.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn add_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        batch: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addRewardsBatch")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&batch)
            .original_result()
    }

    /// Cancel a specified rewards batch. Remaining tokens are sent back to a beneficiary.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The identifier of the pool provider.
    /// - `pool` - The pool identifier of the pool.
    /// - `batch` - The rewards batch identifier.
    /// - `opt_to` - The beneficiary address for the remaining tokens (optional).
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - The caller is selected if no beneficiary is given.
    ///
    pub fn cancel_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<usize>,
        Arg3: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        batch: Arg2,
        opt_to: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelRewardsBatch")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&batch)
            .argument(&opt_to)
            .original_result()
    }

    /// Removes a specified rewards batch from the array of rewards batches iff it has been fully distributed.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `pool` - The pool identifier of the pool.
    /// - `batch` - The rewards batch identifier.
    ///
    /// # Notes
    ///
    /// - Can be called by anyone.
    /// - Takes into consideration possible rounding errors but it is conservative.
    ///
    pub fn remove_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        batch: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeRewardsBatch")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&batch)
            .original_result()
    }

    /// Removes a specified rewards batch from the array of rewards batches iff it has been fully distributed within a
    /// given tolerance amount.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `pool` - The pool identifier of the pool.
    /// - `batch` - The rewards batch identifier.
    /// - `tolerance` - The tolerance in wad, such that 1 wad = 100%.
    ///
    /// # Notes
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn admin_remove_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<usize>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        batch: Arg2,
        tolerance: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("adminRemoveRewardsBatch")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&batch)
            .argument(&tolerance)
            .original_result()
    }

    /// Updates a given rewards batch based on a new speed. The new speed of rewards also changes the remaining
    /// distribution time period.
    ///
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `pool` - The pool identifier of the pool.
    /// - `batch` - The rewards batch identifier.
    /// - `new_speed` - The new speed of rewards in wad.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn update_rewards_batch_speed<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<usize>,
        Arg3: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        batch: Arg2,
        new_speed: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRewardsBatchSpeed")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&batch)
            .argument(&new_speed)
            .original_result()
    }

    /// Updates a given rewards batch based on a new period. The new period also changes the speed of rewards.
    ///
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `token_id` - The token identifier of the token.
    /// - `batch` - The rewards batch identifier.
    /// - `new_dt` - The new period.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn update_rewards_batch_remaining_period<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<usize>,
        Arg3: ProxyArg<u64>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        batch: Arg2,
        new_dt: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRewardsBatchRemainingPeriod")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&batch)
            .argument(&new_dt)
            .original_result()
    }

    /// Withdraws the undistributed or penalized rewards.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `rewards_token_id` - The rewards token identifier.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - Withdraws the total undistributed amounts for the specified token ID or EGLD and sends them to the admin
    ///   address.
    ///
    pub fn withdraw_penalized_rewards<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        rewards_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdrawPenalizedRewards")
            .argument(&provider)
            .argument(&rewards_token)
            .original_result()
    }

    /// Sets the Extra Rewards Ratio.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `extra_rewards_ratio` - New value of extra rewards ratio.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    /// - Have a maximum allowed
    ///
    pub fn set_extra_rewards_ratio<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        provider: Arg0,
        extra_rewards_ratio: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setExtraRewardsRatio")
            .argument(&provider)
            .argument(&extra_rewards_ratio)
            .original_result()
    }

    /// Enables support for boosting rewards batches for a given pool provider.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn enable_rewards_batch_boosting<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("enableRewardsBatchBoosting")
            .argument(&provider)
            .original_result()
    }

    /// Disables support for boosting rewards batches for a given pool provider.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin.
    ///
    pub fn disable_rewards_batch_boosting<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("disableRewardsBatchBoosting")
            .argument(&provider)
            .original_result()
    }

    /// Boosts the rewards of a given rewards token in the specified pool provider by converting the rewards tokens into
    /// Hatom's governance token with a premium.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `premium` - the premium in wad, such that 1 wad = 100%.
    /// - `fwd_swap_amount` - an small amount of tokens to test the swap path.
    /// - `fwd_swap_path` - the swap path to convert the rewards batch tokens into Hatom's governance tokens.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - If rewards token is EGLD, swaps will add a EGLD => WEGLD step first. Also, the swap path needs to use the
    ///   WEGLD token identifier.
    ///
    pub fn boost_rewards<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<ManagedVec<Env::Api, SwapStep<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        premium: Arg1,
        fwd_swap_amount: Arg2,
        fwd_swap_path: Arg3,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("boostRewards")
            .argument(&provider)
            .argument(&premium)
            .argument(&fwd_swap_amount)
            .argument(&fwd_swap_path)
            .original_result()
    }

    /// Updates the premium of a given booster in the specified pool provider and, if a payment is provided, adds it to the
    /// booster's amount.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `rewards_token_id` - the rewards token identifier for which we wish to update its booster.
    /// - `premium` - the premium in wad, such that 1 wad = 100%.
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    /// - Cannot change the swap path. That requires canceling the booster and creating a new one.
    ///
    pub fn update_booster<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        provider: Arg0,
        rewards_token: Arg1,
        premium: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("updateBooster")
            .argument(&provider)
            .argument(&rewards_token)
            .argument(&premium)
            .original_result()
    }

    /// Cancels a given booster for the specified pool provider and sends the remaining tokens back to the caller.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `rewards_token_id` - the rewards token identifier for which we wish to cancel its booster.
    /// - `opt_to` - the beneficiary address for the remaining tokens (optional).
    ///
    /// # Notes:
    ///
    /// - Can only be called by the admin or rewards manager.
    ///
    pub fn cancel_booster<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        rewards_token: Arg1,
        opt_to: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelBooster")
            .argument(&provider)
            .argument(&rewards_token)
            .argument(&opt_to)
            .original_result()
    }

    pub fn set_account_manager_deployer<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account_manager_deployer: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAccountManagerDeployer")
            .argument(&account_manager_deployer)
            .original_result()
    }

    pub fn config_promotion_data<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pair: Arg0,
        farm: Arg1,
        dual_farm: Arg2,
        staking: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("configPromotionData")
            .argument(&pair)
            .argument(&farm)
            .argument(&dual_farm)
            .argument(&staking)
            .original_result()
    }

    pub fn enable_promotion(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("enablePromotion")
            .original_result()
    }

    pub fn disable_promotion(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("disablePromotion")
            .original_result()
    }

    pub fn enable_stake(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("enableStake")
            .original_result()
    }

    pub fn disable_stake(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("disableStake")
            .original_result()
    }

    pub fn enable_cross_reallocation(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("enableCrossReallocation")
            .original_result()
    }

    pub fn disable_cross_reallocation(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("disableCrossReallocation")
            .original_result()
    }

    /// Reallocates tokens from one pool provider to another.
    ///
    /// The caller must be a staker in the source pool provider. The pricing method used in both unstake and stake operations is "last price,\
    /// which helps optimize gas usage.
    ///
    /// # Arguments
    ///
    /// - `from_provider`- The address of the source pool provider.
    /// - `to_provider`- The address of the destination pool provider.
    /// - `payment` - The payment to be used in both unstake and stake operations.
    ///
    pub fn reallocate<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<EsdtTokenPayment<Env::Api>>,
    >(
        self,
        from_provider: Arg0,
        to_provider: Arg1,
        payment: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reallocate")
            .argument(&from_provider)
            .argument(&to_provider)
            .argument(&payment)
            .original_result()
    }

    /// Reallocates tokens between different pool providers across accounts.
    ///
    /// The reallocation occurs between the caller's account and the associated manager account, depending on the selected reallocation side.
    /// The pricing method used in both unstake and stake operations is "last price," which helps optimize gas usage.
    ///
    /// # Arguments
    ///
    /// - `side` - The side of the reallocation. `ToManager` or `FromManager`.
    /// - `from_provider` - The address of the source pool provider in the origin account.
    /// - `to_provider` - The address of the destination pool provider in the destination account.
    /// - `payment` - The payment to be used in both unstake and stake operations.
    ///
    pub fn cross_reallocate<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<EsdtTokenPayment<Env::Api>>,
        Arg3: ProxyArg<ReallocationType>,
    >(
        self,
        from_provider: Arg0,
        to_provider: Arg1,
        payment: Arg2,
        reallocation_type: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("crossReallocate")
            .argument(&from_provider)
            .argument(&to_provider)
            .argument(&payment)
            .argument(&reallocation_type)
            .original_result()
    }

    /// Allows users to stake valid tokens within a pool provider to start earning rewards.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `opt_account` - An optional account address. If not provided, the caller's address will be used.
    ///
    /// # Notes:
    ///
    /// - The pool provider must be active.
    /// - The staked amount must be greater than zero.
    /// - The token must be whitelisted in the pool provider.
    ///
    pub fn stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        opt_account: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("stake")
            .argument(&provider)
            .argument(&opt_account)
            .original_result()
    }

    /// Allows users to unstake their staked tokens. This process starts a cooldown period, after which the user can claim back the tokens.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `payment` - An ESDT token payment describing the token identifier, nonce, and amount to be unstaked.
    /// - `pricing_method` - The pricing method to be used.
    /// - `opt_max_cooldown_period` - The maximum accepted cooldown period for the claim.
    ///
    /// # Notes:
    ///
    /// - The pool provider must exist.
    /// - The unstaked amount must be greater than zero.
    ///
    pub fn unstake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EsdtTokenPayment<Env::Api>>,
        Arg2: ProxyArg<PricingMethod>,
        Arg3: ProxyArg<OptionalValue<u64>>,
    >(
        self,
        provider: Arg0,
        payment: Arg1,
        pricing_method: Arg2,
        opt_max_cooldown_period: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unstake")
            .argument(&provider)
            .argument(&payment)
            .argument(&pricing_method)
            .argument(&opt_max_cooldown_period)
            .original_result()
    }

    /// Allows users to claim their unstaked tokens from a specific pool provider after the cooldown period has elapsed.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `claim_id`: The claim identifier.
    ///
    pub fn claim<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        claim_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claim")
            .argument(&provider)
            .argument(&claim_id)
            .original_result()
    }

    /// Allows users to stake the tokens available in a claim, even if the cooldown period has not elapsed.
    ///
    /// # Arguments:
    ///
    /// - `from_provider` - The address of the pool provider from which the claim originated.
    /// - `claim_id` - The claim identifier.
    /// - `to_provider` - The address of the pool provider where the tokens will be staked.
    ///
    pub fn stake_claim<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        from_provider: Arg0,
        claim_id: Arg1,
        to_provider: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("stakeClaim")
            .argument(&from_provider)
            .argument(&claim_id)
            .argument(&to_provider)
            .original_result()
    }

    /// Updates the rewards batches state for all pools in the given pool provider.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `pools`: An array of pool identifiers.
    ///
    /// # Notes:
    ///
    /// - If no pools are provided, then all whitelisted pools in the pool provider will be updated.
    ///
    pub fn update_rewards_batches_state<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, TokenIdentifier<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        pool_tokens: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateRewardsBatchesState")
            .argument(&provider)
            .argument(&pool_tokens)
            .original_result()
    }

    /// Distributes all rewards from the given pool provider, accounts and pools.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `accounts`: An array of account addresses.
    /// - `pools`: An array of pool identifiers.
    ///
    /// # Notes:
    ///
    /// - If no pools are provided, then all whitelisted pools in the pool provider will be used.
    /// - If no accounts are provided, then only the caller will get his rewards distributed.
    ///
    pub fn distribute_rewards<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedVec<Env::Api, TokenIdentifier<Env::Api>>>,
        Arg2: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        pool_tokens: Arg1,
        accounts: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("distributeRewards")
            .argument(&provider)
            .argument(&pool_tokens)
            .argument(&accounts)
            .original_result()
    }

    /// Claims all rewards from all rewards batches corresponding to the pool provider, accounts and pools.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The address of the pool provider.
    /// - `boost`: Whether to boost the rewards or not.
    /// - `accounts`: An array of account addresses.
    /// - `pools`: An array of pool identifiers.
    /// - `rewards_tokens_to_ignore`: An array of rewards tokens to ignore.
    /// - `opt_min_boosted_rewards_out`: An optional minimum amount of boosted rewards out.
    ///
    /// # Notes:
    ///
    /// - If `boost` is enabled, then the rewards will be boosted using the rewards booster.
    /// - If no pools are specified, then all the pools where the user has balance in the Pool Provider will be used.
    /// - If no accounts are provided, then only the caller will claim his rewards.
    ///
    pub fn claim_rewards<
        Arg0: ProxyArg<bool>,
        Arg1: ProxyArg<bool>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedVec<Env::Api, TokenIdentifier<Env::Api>>>,
        Arg4: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg5: ProxyArg<ManagedVec<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>>,
        Arg6: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        boost: Arg0,
        distribute: Arg1,
        provider: Arg2,
        pools: Arg3,
        accounts_in: Arg4,
        reward_tokens_in: Arg5,
        opt_min_boosted_rewards_out: Arg6,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<ManagedAddress<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimRewards")
            .argument(&boost)
            .argument(&distribute)
            .argument(&provider)
            .argument(&pools)
            .argument(&accounts_in)
            .argument(&reward_tokens_in)
            .argument(&opt_min_boosted_rewards_out)
            .original_result()
    }

    /// C*_i
    /// Returns the account's compliance integral at the specified provider. The compliance integral is calculated as
    /// the integral of both capped and uncapped compliances for the account over time.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The provider address.
    /// - `account` - The account address.
    ///
    pub fn get_account_compliance_integral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, u64, BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountComplianceIntegral")
            .argument(&provider)
            .argument(&account)
            .original_result()
    }

    /// C*_im
    /// Returns the account's pool token compliance integral at the specified provider. This value represents the
    /// account's compliance integral at the time of rewards distribution for a given pool token in the specified
    /// provider.
    ///
    /// # Arguments:
    ///
    /// - `provider` - The provider address.
    /// - `account` - The account address.
    /// - `pool_token` - The pool token identifier.
    ///
    pub fn get_account_pool_compliance_integral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, u64, BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPoolComplianceIntegral")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&account)
            .original_result()
    }

    pub fn get_staking_ratio_threshold_integral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingRatioThresholdIntegral")
            .argument(&provider)
            .argument(&pool_token)
            .original_result()
    }

    /// Retrieves the staking ratio threshold integral for a given account in a specified pool provider and pool. If no
    /// previous account specific integral exists for the given pool and pool provider, the function retrieves the integral
    /// with the current global integral staking ratio threshold integral and the current timestamp.
    ///
    pub fn get_account_staking_ratio_threshold_integral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountStakingRatioThresholdIntegral")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&account)
            .original_result()
    }

    /// Returns the price integral for a given token.
    ///
    /// # Arguments:
    ///
    /// - `pool provider` - The address of the pool provider.
    /// - `token` - The identifier of the token, which could represent either a collateral token or a stake token.
    ///
    pub fn get_price_integral<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPriceIntegral")
            .argument(&token)
            .original_result()
    }

    /// Returns the price integral for a given account and token in the specified pool provider.
    ///
    /// # Arguments:
    ///
    /// - `pool provider` - The address of the pool provider.
    /// - `account` - The address of the account.
    /// - `token` - The identifier of the token.
    ///
    pub fn get_account_price_integral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        token: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPriceIntegral")
            .argument(&provider)
            .argument(&token)
            .argument(&account)
            .original_result()
    }

    /// Integrates the price information for a specified pool provider across multiple pools and stake tokens.
    ///
    /// # Arguments
    ///
    /// - `pool provider` - The address of the pool provider.
    /// - `tokens` - A list of token identifiers to integrate. This can include both stake tokens and other types of
    ///   tokens associated with a pool provider.
    ///
    pub fn integrate_prices<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, TokenIdentifier<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        tokens: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("integratePrices")
            .argument(&provider)
            .argument(&tokens)
            .original_result()
    }

    /// Calculates the instant extra compliance for a given account in a specified pool provider.
    ///
    pub fn get_instantaneous_extra_compliance<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getInstantaneousExtraCompliance")
            .argument(&provider)
            .argument(&account)
            .original_result()
    }

    pub fn is_finalized(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isFinalized")
            .original_result()
    }

    pub fn is_provider_state<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<State>,
    >(
        self,
        provider: Arg0,
        state: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isProviderState")
            .argument(&provider)
            .argument(&state)
            .original_result()
    }

    pub fn is_whitelisted_stake_token<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        stake_token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isWhitelistedStakeToken")
            .argument(&stake_token)
            .original_result()
    }

    pub fn is_pool_whitelisted_by_any_provider<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        pool_token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isWhitelistedPoolToken")
            .argument(&pool_token)
            .original_result()
    }

    pub fn is_trusted_staker<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isTrustedStaker")
            .argument(&address)
            .original_result()
    }

    pub fn pool_has_active_rewards_batch<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedVec<Env::Api, RewardsBatchType>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        batch_types: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("poolHasActiveRewardsBatch")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&batch_types)
            .original_result()
    }

    pub fn get_whitelisted_stake_tokens(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedStakeTokens")
            .original_result()
    }

    pub fn get_account_stake_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountStakeTokens")
            .argument(&provider)
            .argument(&account)
            .original_result()
    }

    pub fn get_global_account_stake_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getGlobalAccountStakeTokens")
            .argument(&account)
            .original_result()
    }

    pub fn get_whitelisted_pool_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedPoolTokens")
            .argument(&provider)
            .original_result()
    }

    pub fn get_total_pool_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalPoolTokens")
            .argument(&provider)
            .argument(&pool_token)
            .original_result()
    }

    pub fn get_account_pool_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPoolTokens")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&account)
            .original_result()
    }

    pub fn get_account_stake_token_nonces<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        stake_token: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountStakeTokenNonces")
            .argument(&provider)
            .argument(&stake_token)
            .argument(&account)
            .original_result()
    }

    pub fn get_account_provider_pools<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountProviderPools")
            .argument(&provider)
            .argument(&account)
            .original_result()
    }

    pub fn get_account_pending_reward_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPendingRewardTokens")
            .argument(&provider)
            .argument(&account)
            .original_result()
    }

    pub fn penalized_rewards<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        rewards_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPenalizedRewards")
            .argument(&provider)
            .argument(&rewards_token)
            .original_result()
    }

    pub fn base_stored_account_pool_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseStoredAccountPoolTokens")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&account)
            .original_result()
    }

    pub fn base_stored_total_pool_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBaseStoredTotalPoolTokens")
            .argument(&provider)
            .argument(&pool_token)
            .original_result()
    }

    pub fn boosted_stored_account_pool_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBoostedStoredAccountPoolTokens")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&account)
            .original_result()
    }

    pub fn boosted_stored_total_pool_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBoostedStoredTotalPoolTokens")
            .argument(&provider)
            .argument(&pool_token)
            .original_result()
    }

    pub fn total_extra_pool_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalExtraPoolTokens")
            .argument(&provider)
            .argument(&pool_token)
            .original_result()
    }

    pub fn account_extra_pool_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        account: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountExtraPoolTokens")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&account)
            .original_result()
    }

    pub fn rewards_booster<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        rewards_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, RewardsBooster<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsBooster")
            .argument(&provider)
            .argument(&rewards_token)
            .original_result()
    }

    pub fn rewards_manager(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsManager")
            .original_result()
    }

    pub fn account_accrued_rewards<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
        token_id: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountAccruedRewards")
            .argument(&provider)
            .argument(&account)
            .argument(&token_id)
            .original_result()
    }

    pub fn account_batch_rewards_index<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        account: Arg2,
        batch: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountBatchRewardsIndex")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&account)
            .argument(&batch)
            .original_result()
    }

    pub fn next_rewards_batch_id<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNextRewardsBatchId")
            .argument(&provider)
            .argument(&pool_token)
            .original_result()
    }

    pub fn rewards_batches<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, RewardsBatch<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsBatches")
            .argument(&provider)
            .argument(&pool_token)
            .original_result()
    }

    pub fn staking_ratio_threshold<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakingRatioThreshold")
            .argument(&provider)
            .argument(&pool_token)
            .original_result()
    }

    pub fn extra_rewards_ratio<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getExtraRewardsRatio")
            .argument(&provider)
            .original_result()
    }

    pub fn rewards_batch_position<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        pool_token: Arg1,
        batch: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getRewardsBatchPosition")
            .argument(&provider)
            .argument(&pool_token)
            .argument(&batch)
            .original_result()
    }

    pub fn total_stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        stake_token: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalStake")
            .argument(&provider)
            .argument(&stake_token)
            .original_result()
    }

    pub fn account_stake_equivalent<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
        stake_token: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountStakeEquivalent")
            .argument(&provider)
            .argument(&account)
            .argument(&stake_token)
            .original_result()
    }

    pub fn account_token_nonce_stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<u64>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
        stake_token: Arg2,
        stake_nonce: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountTokenNonceStake")
            .argument(&provider)
            .argument(&account)
            .argument(&stake_token)
            .argument(&stake_nonce)
            .original_result()
    }

    pub fn account_claims_by_id<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<usize>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
        claim_id: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Claim<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountClaimsById")
            .argument(&provider)
            .argument(&account)
            .argument(&claim_id)
            .original_result()
    }

    pub fn last_claim_id<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        provider: Arg0,
        account: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastClaimId")
            .argument(&provider)
            .argument(&account)
            .original_result()
    }

    pub fn promotion_data(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, PromotionData<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPromotionData")
            .original_result()
    }

    pub fn promotion_state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, FeatureState> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPromotionState")
            .original_result()
    }

    pub fn stake_state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, FeatureState> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakeState")
            .original_result()
    }

    pub fn cross_reallocation_state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, FeatureState> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCrossReallocationState")
            .original_result()
    }

    /// Forwards to the corresponding internal method based on the payment and arguments.
    pub fn promote<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EsdtTokenPayment<Env::Api>>,
        Arg2: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<OptionalValue<MultiValue2<BigUint<Env::Api>, BigUint<Env::Api>>>>,
    >(
        self,
        provider: Arg0,
        unstake_payment: Arg1,
        target_stake_token: Arg2,
        min_amounts: Arg3,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("promote")
            .argument(&provider)
            .argument(&unstake_payment)
            .argument(&target_stake_token)
            .argument(&min_amounts)
            .original_result()
    }

    /// Unstakes a staked amount of a given stake token, converts it to something else and stakes it again afterwards.
    pub fn promote_stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EsdtTokenPayment<Env::Api>>,
        Arg2: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        unstake_payment: Arg1,
        target_stake_token: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("promoteStake")
            .argument(&provider)
            .argument(&unstake_payment)
            .argument(&target_stake_token)
            .original_result()
    }

    /// Accepts HTM and promotes it to sHTM, or accepts LP and promotes it to Farm or Dual Farm, or accepts Farm and
    /// promotes it to Dual Farm. It stakes it again afterwards.
    pub fn stake_and_promote<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        provider: Arg0,
        target_stake_token: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("stakeAndPromote")
            .argument(&provider)
            .argument(&target_stake_token)
            .original_result()
    }

    /// Accepts WEGLD, promotes an HTM staked amount to LP, Farm or Dual and stakes it again afterwards.
    pub fn promote_stake_with_wrapped_egld<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<EsdtTokenPayment<Env::Api>>,
        Arg2: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<OptionalValue<MultiValue2<BigUint<Env::Api>, BigUint<Env::Api>>>>,
    >(
        self,
        provider: Arg0,
        unstake_payment: Arg1,
        target_stake_token: Arg2,
        min_amounts: Arg3,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("promoteStakeWithWrappedEgld")
            .argument(&provider)
            .argument(&unstake_payment)
            .argument(&target_stake_token)
            .argument(&min_amounts)
            .original_result()
    }

    /// Accepts HTM and WEGLD, promotes it to LP, Farm or Dual and stakes it again afterwards.
    pub fn stake_and_promote_with_wrapped_egld<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<OptionalValue<MultiValue2<BigUint<Env::Api>, BigUint<Env::Api>>>>,
    >(
        self,
        provider: Arg0,
        target_stake_token: Arg1,
        min_amounts: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("stakeAndPromoteWithWrappedEgld")
            .argument(&provider)
            .argument(&target_stake_token)
            .argument(&min_amounts)
            .original_result()
    }

    pub fn claim_xex_rewards<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedVec<Env::Api, EsdtTokenPayment<Env::Api>>>,
    >(
        self,
        provider: Arg0,
        unstake_payments: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimXexRewards")
            .argument(&provider)
            .argument(&unstake_payments)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Eq, Copy, Clone, Debug)]
pub enum PricingMethod {
    ReliablePrice,
    LastPrice,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq)]
pub struct PoolProviderData {
    pub state: State,
    pub cooldown_period: u64,
    pub max_account_stakes: usize,
    pub max_batches: usize,
    pub boosting_state: BoostingState,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Eq, Copy, Clone, Debug, ManagedVecItem, NestedEncode, NestedDecode)]
pub enum State {
    Inactive,
    Active,
    Finalized,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Eq, Copy, Clone, Debug, NestedEncode, NestedDecode)]
pub enum BoostingState {
    Inactive,
    Active,
    Finalized,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Eq, Copy, Clone, Debug, ManagedVecItem, NestedEncode, NestedDecode)]
pub enum RewardsBatchType {
    Base,
    Boosted,
    Extra,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct SwapStep<Api>
where
    Api: ManagedTypeApi,
{
    pub pair_address: ManagedAddress<Api>,
    pub input_token_id: TokenIdentifier<Api>,
    pub output_token_id: TokenIdentifier<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Eq, Copy, Clone, Debug, NestedEncode, NestedDecode)]
pub enum ReallocationType {
    FromProxyToAccount,
    FromAccountToProxy,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct RewardsBatch<Api>
where
    Api: ManagedTypeApi,
{
    pub id: usize,
    pub batch_type: RewardsBatchType,
    pub pool: TokenIdentifier<Api>,
    pub rewards_token: EgldOrEsdtTokenIdentifier<Api>,
    pub amount: BigUint<Api>,
    pub distributed_amount: BigUint<Api>,
    pub speed: BigUint<Api>,
    pub index: BigUint<Api>,
    pub start_time: u64,
    pub last_time: u64,
    pub end_time: u64,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct Claim<Api>
where
    Api: ManagedTypeApi,
{
    pub id: usize,
    pub payment: EsdtTokenPayment<Api>,
    pub claim_timestamp: u64,
    pub claimed: bool,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct RewardsBooster<Api>
where
    Api: ManagedTypeApi,
{
    pub token_id: EgldOrEsdtTokenIdentifier<Api>,
    pub premium: BigUint<Api>,
    pub amount_left: BigUint<Api>,
    pub distributed_amount: BigUint<Api>,
    pub swap_path: ManagedVec<Api, SwapStep<Api>>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, ManagedVecItem)]
pub struct PromotionData<Api>
where
    Api: ManagedTypeApi,
{
    pub pair: ManagedAddress<Api>,
    pub farm: ManagedAddress<Api>,
    pub dual_farm: ManagedAddress<Api>,
    pub staking: ManagedAddress<Api>,
    pub lp_token: TokenIdentifier<Api>,
    pub farm_token: TokenIdentifier<Api>,
    pub dual_farm_token: TokenIdentifier<Api>,
    pub staking_token: TokenIdentifier<Api>,
    pub is_first_token: bool,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub enum FeatureState {
    Disabled,
    Enabled,
}
