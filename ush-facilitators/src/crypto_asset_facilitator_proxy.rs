// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct CryptoAssetFacilitatorProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for CryptoAssetFacilitatorProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = CryptoAssetFacilitatorProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        CryptoAssetFacilitatorProxyMethods { wrapped_tx: tx }
    }
}

pub struct CryptoAssetFacilitatorProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> CryptoAssetFacilitatorProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the contract. 
    ///  
    /// # Arguments: 
    ///  
    /// - `collateral_token_id` - The collateral token identifier. 
    /// - `ush_minter` - The USH minter contract address. 
    /// - `controller` - The Lending Protocol Controller's contract address. 
    /// - `opt_admin` - An optional admin address for the contract. 
    ///  
    pub fn init<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        collateral_token_id: Arg0,
        ush_minter: Arg1,
        controller: Arg2,
        opt_admin: Arg3,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&collateral_token_id)
            .argument(&ush_minter)
            .argument(&controller)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> CryptoAssetFacilitatorProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> CryptoAssetFacilitatorProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address. 
    ///  
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one. 
    ///  
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_pending_admin` - The new pending admin address. 
    ///  
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint. 
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// Utility function to highlight that this smart contract is a Crypto Asset Facilitator. 
    ///  
    pub fn is_crypto_asset_facilitator(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isCryptoAssetFacilitator")
            .original_result()
    }

    /// Utility function used by other modules to check if they are calling the correct Crypto Asset Facilitator. 
    ///  
    pub fn is_crypto_asset_facilitator_verified<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        collateral_token_id: Arg0,
        borrow_token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isCryptoAssetFacilitatorVerified")
            .argument(&collateral_token_id)
            .argument(&borrow_token_id)
            .original_result()
    }

    /// Checks whether the current state of the smart contract is active. 
    ///  
    pub fn is_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isActive")
            .original_result()
    }

    /// Checks whether the current state of collateral is active. 
    ///  
    pub fn is_collateral_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isCollateralActive")
            .original_result()
    }

    /// Checks whether the current state of borrowing is active. 
    ///  
    pub fn is_borrow_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isBorrowActive")
            .original_result()
    }

    /// Checks whether the current state of liquidations is active. 
    ///  
    pub fn is_liquidation_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isLiquidationActive")
            .original_result()
    }

    /// Checks whether the specified account is whitelisted. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account to check. 
    ///  
    pub fn is_whitelisted_account<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isWhitelistedAccount")
            .argument(&account)
            .original_result()
    }

    /// Updates the collateral factor if possible and returns its updated value. 
    ///  
    pub fn update_and_get_collateral_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("updateAndGetCollateralFactor")
            .original_result()
    }

    /// Returns the collateral token price from the Oracle. 
    ///  
    pub fn get_collateral_token_price(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralTokenPrice")
            .original_result()
    }

    /// Returns the borrow token price (i.e. the USH token price) from the Oracle. 
    ///  
    pub fn get_borrow_token_price(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowTokenPrice")
            .original_result()
    }

    /// Returns the current close factor. If not set, it returns the minimum allowed close factor. 
    ///  
    pub fn get_close_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCloseFactor")
            .original_result()
    }

    /// Returns the current liquidation incentive. If not set, it returns the minimum allowed liquidation incentive, which is 
    /// compliant with the default protocol seize share of 0% and the maximum collateral factor of 90%. 
    ///  
    pub fn get_liquidation_incentive(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationIncentive")
            .original_result()
    }

    /// Returns all the whitelisted accounts. 
    ///  
    pub fn get_whitelisted_accounts(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedAccounts")
            .original_result()
    }

    /// Activates the Crypto Asset Facilitator. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn activate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("activate")
            .original_result()
    }

    /// Sets the collateral status. 
    ///  
    /// # Arguments: 
    ///  
    /// - `pause` - The new collateral status. `true` means paused, `false` means active. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_collateral_status<
        Arg0: ProxyArg<bool>,
    >(
        self,
        pause: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCollateralStatus")
            .argument(&pause)
            .original_result()
    }

    /// Sets the borrow status. 
    ///  
    /// # Arguments: 
    ///  
    /// - `pause` - The new borrow status. `true` means paused, `false` means active. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_borrow_status<
        Arg0: ProxyArg<bool>,
    >(
        self,
        pause: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBorrowStatus")
            .argument(&pause)
            .original_result()
    }

    /// Sets the liquidation status. 
    ///  
    /// # Arguments: 
    ///  
    /// - `pause` - The new liquidation status. `true` means paused, `false` means active. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_liquidation_status<
        Arg0: ProxyArg<bool>,
    >(
        self,
        pause: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidationStatus")
            .argument(&pause)
            .original_result()
    }

    /// Updates the collateral cap. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_collateral_cap` - The collateral cap. `None` means no cap. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_collateral_cap<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_collateral_cap: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCollateralCap")
            .argument(&opt_collateral_cap)
            .original_result()
    }

    /// Updates the borrow cap. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_borrow_cap` - The borrow cap. `None` means no cap. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_borrow_cap<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_borrow_cap: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBorrowCap")
            .argument(&opt_borrow_cap)
            .original_result()
    }

    /// Sets the collateral factor or loan to value. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_collateral_factor` - The new collateral factor in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The new collateral factor must not exceed the maximum allowed. 
    /// - The new collateral factor cannot be lower than the previous one by more than the maximum allowed decrease. 
    ///  
    pub fn set_collateral_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        new_collateral_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCollateralFactor")
            .argument(&new_collateral_factor)
            .original_result()
    }

    /// Sets the close factor used at liquidations. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_close_factor` - The new close factor in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_close_factor<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        close_factor: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCloseFactor")
            .argument(&close_factor)
            .original_result()
    }

    /// Updates the liquidation incentive for liquidations. 
    ///  
    /// # Arguments: 
    ///  
    /// - `liquidation_incentive` - The new liquidation incentive in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The new liquidation incentive should not be less than the amount that would yield losses for liquidators. 
    /// - The new liquidation incentive should be less than `1 / eff_ltv`, which is conservatively assumed to be `1 / 
    ///   max_ltv`. Otherwise, there won't be a Risky region. 
    ///  
    pub fn set_liquidation_incentive<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        liquidation_incentive: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidationIncentive")
            .argument(&liquidation_incentive)
            .original_result()
    }

    /// Updates the protocol seize share, i.e. the portion of the seized amount that is kept by the protocol. 
    ///  
    /// # Arguments: 
    ///  
    /// - `protocol_seize_share` - The new protocol seize share in wad. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The new protocol seize share cannot exceed the amount that would yield losses for liquidators. 
    ///  
    pub fn set_protocol_seize_share<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        protocol_seize_share: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setProtocolSeizeShare")
            .argument(&protocol_seize_share)
            .original_result()
    }

    /// Withdraws an specified amount of collateral token from the reserves to the admin account. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_delta_reserves` - The amount of reserves to withdraw. If not provided, the entire revenue is withdrawn. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn reduce_reserves<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_delta_reserves: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("reduceReserves")
            .argument(&opt_delta_reserves)
            .original_result()
    }

    /// Whitelist an account to be able to interact with the protocol. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - Account to whitelist. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - Fails if the account is already whitelisted. 
    ///  
    pub fn whitelist_account<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("whitelistAccount")
            .argument(&account)
            .original_result()
    }

    /// Removes an account from the whitelisted members list. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - Account to remove. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - Fails if the account is not whitelisted. 
    /// - The removed account can still repay the borrow and take out the collateral. 
    ///  
    pub fn remove_account<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAccount")
            .argument(&account)
            .original_result()
    }

    /// Allows users to add collateral to their positions. 
    ///  
    /// # Notes: 
    ///  
    /// - A user can pay with the Crypto Asset Facilitator's collateral token. 
    /// - Returns the amount of token that was accredited to the user. 
    ///  
    pub fn add_collateral(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addCollateral")
            .original_result()
    }

    /// Repays an outstanding USH borrow. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_borrower` - An optional borrower address. Otherwise, caller is assumed to be the borrower. 
    ///  
    /// Notes: 
    ///  
    /// - The repayment amount can be higher than the outstanding borrow. In such case, the remainder is returned. 
    ///  
    pub fn repay_borrow<
        Arg0: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        opt_borrower: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("repayBorrow")
            .argument(&opt_borrower)
            .original_result()
    }

    /// Liquidates borrower through a borrow repayment and collateral seizure. 
    ///  
    /// # Arguments: 
    ///  
    /// - `borrower` - The account to be liquidated. 
    /// - `opt_min_tokens` - The minimum amount of tokens to be seized from the borrower. 
    ///  
    pub fn liquidate_borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        borrower: Arg0,
        opt_min_tokens: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, MultiValue2<EgldOrEsdtTokenPayment<Env::Api>, EgldOrEsdtTokenPayment<Env::Api>>> {
        self.wrapped_tx
            .raw_call("liquidateBorrow")
            .argument(&borrower)
            .argument(&opt_min_tokens)
            .original_result()
    }

    /// Allows users to remove collateral from the protocol. 
    ///  
    /// # Arguments: 
    ///  
    /// - `opt_collateral_out` - An optional amount of collateral to withdraw. If not provided, the user will withdraw all of 
    ///   his collateral. 
    ///  
    /// # Notes: 
    ///  
    /// - The user must remain solvent after the withdrawal. 
    ///  
    pub fn remove_collateral<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_collateral_out: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeCollateral")
            .argument(&opt_collateral_out)
            .original_result()
    }

    /// Allows a user to borrow USH from the protocol. 
    ///  
    /// # Arguments: 
    ///  
    /// - `ush_amount` - The amount of USH to borrow. 
    ///  
    /// # Notes: 
    ///  
    /// - The user must have enough collateral to borrow. 
    /// - The user must remain solvent after the borrow. 
    ///  
    pub fn borrow<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        ush_amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("borrow")
            .argument(&ush_amount)
            .original_result()
    }

    /// Checks if an account is currently eligible for liquidations. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account to check. 
    ///  
    pub fn is_risky<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isRisky")
            .argument(&account)
            .original_result()
    }

    /// Simulates the risk profile of an account based on the current collateral and borrow amounts and a simulated 
    /// withdrawal of collateral or a borrow. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account for which to simulate the risk profile. 
    /// - `collateral_out` - The simulated amount of collateral to withdraw. 
    /// - `borrow_amount` - The simulated amount of borrow to take. 
    ///  
    pub fn simulate_risk_profile<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        account: Arg0,
        collateral_out: Arg1,
        borrow_amount: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, RiskProfile<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("simulateRiskProfile")
            .argument(&account)
            .argument(&collateral_out)
            .argument(&borrow_amount)
            .original_result()
    }

    /// Stores the smart contract state. 
    pub fn state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getState")
            .original_result()
    }

    /// Stores the collateral status. 
    pub fn collateral_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralStatus")
            .original_result()
    }

    /// Stores the borrow status. 
    pub fn borrow_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowStatus")
            .original_result()
    }

    /// Stores the liquidation status. 
    pub fn liquidation_status(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Status> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLiquidationStatus")
            .original_result()
    }

    /// Stores the collateral token identifier. 
    pub fn collateral_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EgldOrEsdtTokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralTokenId")
            .original_result()
    }

    /// Stores the USH Minter smart contract address. 
    pub fn ush_minter(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshMinter")
            .original_result()
    }

    /// Stores the Controller smart contract address. 
    pub fn controller(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getController")
            .original_result()
    }

    pub fn ush_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshTokenId")
            .original_result()
    }

    /// Stores the collateral cap in collateral tokens. 
    pub fn collateral_cap(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralCap")
            .original_result()
    }

    /// Stores the total collateral amount in collateral token. 
    pub fn total_collateral(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalCollateral")
            .original_result()
    }

    /// Stores the account collateral in collateral token. 
    pub fn account_collateral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountCollateral")
            .argument(&account)
            .original_result()
    }

    /// Stores the borrow cap in USH. 
    pub fn borrow_cap(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<BigUint<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBorrowCap")
            .original_result()
    }

    /// Stores the total amount of outstanding USH borrows. 
    pub fn total_borrows(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalBorrows")
            .original_result()
    }

    /// Stores the account USH borrow. 
    pub fn account_borrow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        borrower: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountBorrow")
            .argument(&borrower)
            .original_result()
    }

    /// Stores the amount of protocol reserves in collateral token. 
    pub fn reserves(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getReserves")
            .original_result()
    }

    /// Stores the current collateral factor. 
    pub fn collateral_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralFactor")
            .original_result()
    }

    /// Stores the next collateral factor. 
    pub fn next_collateral_factor(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (u64, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getNextCollateralFactor")
            .original_result()
    }

    /// Stores the current protocol seize share. 
    pub fn protocol_seize_share(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getProtocolSeizeShare")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq)]
pub enum State {
    Empty,
    Active,
    Inactive,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq)]
pub enum Status {
    Empty,
    Active,
    Paused,
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Clone, Debug)]
pub enum RiskProfile<Api>
where
    Api: ManagedTypeApi,
{
    Solvent(BigUint<Api>),
    RiskyOrInsolvent(BigUint<Api>),
}
