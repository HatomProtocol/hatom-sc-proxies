// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct StableCoinFacilitatorProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for StableCoinFacilitatorProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = StableCoinFacilitatorProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        StableCoinFacilitatorProxyMethods { wrapped_tx: tx }
    }
}

pub struct StableCoinFacilitatorProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> StableCoinFacilitatorProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initialize the Stable Coin Facilitator smart contract. 
    ///  
    /// # Arguments: 
    ///  
    /// - `collateral_token_id` - The collateral token identifier. 
    /// - `ush_minter` - The address of the USH minter. 
    /// - `opt_admin` - An optional admin address for the contract. 
    ///  
    /// Notes: 
    ///  
    /// - If the admin address is not provided, the deployer will be set as the admin. 
    ///  
    pub fn init<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
        Arg2: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        collateral_token_id: Arg0,
        ush_minter: Arg1,
        opt_admin: Arg2,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&collateral_token_id)
            .argument(&ush_minter)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> StableCoinFacilitatorProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> StableCoinFacilitatorProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address. 
    ///  
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one. 
    ///  
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_pending_admin` - The new pending admin address. 
    ///  
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint. 
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// Burns USH by repaying an outstanding borrow. 
    ///  
    ///  
    /// Notes: 
    ///  
    /// - The repayment amount can be higher than the outstanding borrow. In such case, the remainder is returned. 
    ///  
    pub fn burn(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("burn")
            .original_result()
    }

    /// Utility function to highlight that the smart contract is a Stable Coin Facilitator. 
    ///  
    pub fn is_stable_facilitator(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isStableFacilitator")
            .original_result()
    }

    /// Checks whether the current state of the smart contract is active. 
    ///  
    pub fn is_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isActive")
            .original_result()
    }

    /// Checks whether the current mint state is active. 
    ///  
    pub fn is_mint_active(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isMintActive")
            .original_result()
    }

    /// Returns all the crypto assets facilitator accounts. 
    ///  
    pub fn get_historical_allowed_accounts(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getHistoricalAllowedAccounts")
            .original_result()
    }

    /// Activates the Stable Coin Facilitator. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    ///  
    pub fn activate(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("activate")
            .original_result()
    }

    /// Activates the USH mint operation. 
    ///  
    /// # Notes 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn activate_mint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("activateMint")
            .original_result()
    }

    /// Deactivates the USH mint operation. 
    ///  
    /// # Notes 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn deactivate_mint(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("deactivateMint")
            .original_result()
    }

    /// Sets the USH collateral allowance for an account. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account to set the collateral allowance for. 
    /// - `allowance` - The collateral allowance. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    ///  
    pub fn set_collateral_allowance<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        account: Arg0,
        allowance: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setCollateralAllowance")
            .argument(&account)
            .argument(&allowance)
            .original_result()
    }

    /// Allows a user to mint USH through the Stable Coin Facilitator. The user must have sufficient collateral allowance set by the admin. 
    /// The total amount the user wants to mint must be paid using USDT or USDC. If the account pays more than the allowed total, the excess is refunded. 
    ///  
    pub fn mint(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("mint")
            .original_result()
    }

    /// Stores the smart contract state. 
    pub fn state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getState")
            .original_result()
    }

    /// Stores the USH mint state. 
    pub fn mint_state(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, State> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMintState")
            .original_result()
    }

    /// Stores the total USH collateral allowance for each account in collateral units. 
    pub fn collateral_allowance<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralAllowance")
            .argument(&account)
            .original_result()
    }

    /// Stores the account's collateral in a specific collateral token. 
    pub fn account_collateral<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountCollateral")
            .argument(&account)
            .original_result()
    }

    /// Stores the total collateral amount for a specific token. 
    pub fn total_collateral(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalCollateral")
            .original_result()
    }

    /// Stores the USH Minter address. 
    pub fn ush_minter(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshMinter")
            .original_result()
    }

    /// Stores the collateral token identifier. 
    pub fn collateral_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCollateralTokenId")
            .original_result()
    }

    /// Stores the USH token identifier. 
    pub fn ush_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshTokenId")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, PartialEq, Debug)]
pub enum State {
    Empty,
    Active,
    Inactive,
}
