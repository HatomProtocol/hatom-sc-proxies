// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct StakingProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for StakingProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = StakingProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        StakingProxyMethods { wrapped_tx: tx }
    }
}

pub struct StakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> StakingProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initialize the Staking USH Smart Contract. 
    ///  
    /// # Arguments: 
    ///  
    /// - `ush_minter` - The address of the USH Minter contract. 
    /// - `opt_admin` - An optional admin address for the contract. 
    ///  
    /// Notes: 
    ///  
    /// - If the admin address is not provided, the admin will be set as the deployer. 
    ///  
    pub fn init<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        ush_minter: Arg0,
        opt_admin: Arg1,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&ush_minter)
            .argument(&opt_admin)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> StakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> StakingProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Returns the current admin address. 
    ///  
    pub fn get_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAdmin")
            .original_result()
    }

    /// Returns the current pending admin address, if there is one. 
    ///  
    pub fn get_pending_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPendingAdmin")
            .original_result()
    }

    /// Sets the pending admin address to the given address. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_pending_admin` - The new pending admin address. 
    ///  
    pub fn set_pending_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        pending_admin: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setPendingAdmin")
            .argument(&pending_admin)
            .original_result()
    }

    /// Attempts to accept the pending admin, which must be set first using the `set_pending_admin` endpoint. 
    pub fn accept_admin(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("acceptAdmin")
            .original_result()
    }

    /// Gets fx of `from` in terms of `to`. 
    pub fn get_fx<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        from: Arg0,
        from_nonce: Arg1,
        to: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFx")
            .argument(&from)
            .argument(&from_nonce)
            .argument(&to)
            .original_result()
    }

    /// Adds support for a new Ashswap farm token so it can be added later into a stake pool. This function performs validations to ensure the tokens 
    /// are valid and not already supported, assigns the AshFarmProvider for the specified farm token and LP token. 
    ///  
    /// # Arguments: 
    ///  
    /// - `farm_address` - The address of the farm corresponding to the farm token. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The caller should pay any amount of the farm token that wants to support, this amount will be returned to the caller at the end of the call. 
    /// - The Farm Token from the payment must match the farm token from the farm address. 
    /// - The token pair must not be already supported by any other fx provider. 
    /// - The tokens must be valid. 
    ///  
    pub fn support_ash_farm_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        farm_address: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("supportAshFarmToken")
            .argument(&farm_address)
            .original_result()
    }

    /// Adds support for a new Xex farm token. This function performs validations to ensure the tokens are valid and not already supported, 
    /// assigns the XExFarmProvider for the specified farm token and LP token. 
    ///  
    /// # Arguments 
    ///  
    /// - `farm_address`: The address of the farm to register. 
    ///  
    /// # Notes 
    ///  
    /// - Only callable by an admin. 
    /// - The LP token must be identified as the main stake token. 
    /// - The token pair must not already be handled by another FX provider. 
    ///  
    pub fn support_xex_farm_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        farm_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("supportXexFarmToken")
            .argument(&farm_address)
            .original_result()
    }

    /// A utility function to highlight that this smart contract is a Staking smart contract. 
    ///  
    pub fn is_staking(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isStaking")
            .original_result()
    }

    /// Checks whether the specified address is a Rewards Booster observer. 
    ///  
    /// # Arguments: 
    ///  
    /// - `sc_address` - The address of the booster observer to check. 
    ///  
    pub fn is_booster_observer<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        sc_address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isBoosterObserver")
            .argument(&sc_address)
            .original_result()
    }

    /// Checks whether the specified token ID is a whitelisted stake token. 
    ///  
    /// # Arguments: 
    ///  
    /// - `token_id` - The token ID to check. 
    ///  
    pub fn is_whitelisted_stake_token_id<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isWhitelistedStakeTokenId")
            .argument(&token_id)
            .original_result()
    }

    /// Check whether the specified token ID is a main stake token. 
    ///  
    /// # Arguments: 
    ///  
    /// - `token_id` - The token ID to check. 
    ///  
    pub fn is_main_stake_token_id<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isMainStakeTokenId")
            .argument(&token_id)
            .original_result()
    }

    /// Returns all the whitelisted stake tokens. 
    ///  
    pub fn get_whitelisted_stake_tokens(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedStakeTokens")
            .original_result()
    }

    /// Returns all the main stake tokens. 
    ///  
    pub fn get_main_stake_tokens(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMainStakeTokens")
            .original_result()
    }

    /// Returns all the stake tokens that the specified account has staked. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account to get the stake tokens for. 
    ///  
    pub fn get_account_stake_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountStakeTokens")
            .argument(&account)
            .original_result()
    }

    /// Returns only the main tokens for the pools the specified account has staked. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account to get the main tokens for. 
    ///  
    pub fn get_account_main_stake_tokens<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, TokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountMainStakeTokens")
            .argument(&account)
            .original_result()
    }

    /// Returns the total stake for the specified token ID. 
    ///  
    /// # Arguments: 
    ///  
    /// - `token_id` - The token ID to get the total stake for. 
    ///  
    pub fn get_total_stake<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTotalStake")
            .argument(&token_id)
            .original_result()
    }

    /// Returns the total stake of a pool from any token ID of the pool 
    ///  
    /// # Arguments: 
    ///  
    /// - `token_id` - The token ID belonging to the pool. 
    ///  
    pub fn get_pool_stake_from_token<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolStakeFromToken")
            .argument(&token_id)
            .original_result()
    }

    /// Returns the total stake of a pool receiving the pool ID. 
    ///  
    /// # Arguments: 
    ///  
    /// - `pool_id` - The pool ID to get the total stake for. 
    ///  
    pub fn get_pool_stake_from_id<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pool_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPoolStakeFromId")
            .argument(&pool_id)
            .original_result()
    }

    /// Returns all nonces staked by the specified account for the given token ID. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account to get the nonces for. 
    /// - `token_id` - The token ID to get the nonces for. 
    ///  
    pub fn get_account_stake_nonces<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        account: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountStakeNonces")
            .argument(&account)
            .argument(&token_id)
            .original_result()
    }

    /// Returns the total stake for the specified account and token ID. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account to get the total stake for. 
    /// - `token_id` - The token ID to get the total stake for. 
    ///  
    pub fn get_account_token_stake<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        account: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountTokenStake")
            .argument(&account)
            .argument(&token_id)
            .original_result()
    }

    /// Returns the pool stake for the specified account and of the pool to which the token belongs. 
    ///  
    /// # Arguments: 
    ///  
    /// - `account` - The account to get the total stake for. 
    /// - `token_id` - The token ID belonging to the pool. 
    ///  
    pub fn get_account_pool_stake_from_token<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        account: Arg0,
        token_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountPoolStakeFromToken")
            .argument(&account)
            .argument(&token_id)
            .original_result()
    }

    /// Activates a stake token. This will allow users to stake the token. 
    ///  
    /// # Arguments 
    ///  
    /// - `token_id` - The stake token to activate. 
    ///  
    /// # Notes 
    ///  
    /// - The caller must be the admin. 
    /// - The stake token must not be deactivated. 
    ///  
    pub fn activate_stake<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("activateStake")
            .argument(&token_id)
            .original_result()
    }

    /// Deactivates a stake token. This will prevent users from staking the token. 
    ///  
    /// # Arguments 
    ///  
    /// - `token_id` - The stake token to deactivate. 
    ///  
    /// # Notes 
    ///  
    /// - The caller must be the admin. 
    /// - The stake token must be active. 
    ///  
    pub fn deactivate_stake<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("deactivateStake")
            .argument(&token_id)
            .original_result()
    }

    /// Sets a Rewards Booster smart contract as an observer, i.e. as a contract that is notified when accounts deposit or 
    /// withdraw tokens from the Stake Pool. The name Booster Observer is used to reference the Rewards Booster smart contract. 
    ///  
    /// # Arguments: 
    ///  
    /// - `new_booster_observer` - the rewards booster smart contract address. 
    ///  
    /// # Notes 
    ///  
    /// - can only be called by the admin 
    /// - `new_booster_observer` must be a rewards booster smart contract 
    ///  
    pub fn set_booster_observer<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        new_booster_observer: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBoosterObserver")
            .argument(&new_booster_observer)
            .original_result()
    }

    /// Removes Rewards Booster smart contract from being an observer. From this point onwards, this smart contract will not 
    /// be notified of any market change. 
    ///  
    pub fn clear_booster_observer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("clearBoosterObserver")
            .original_result()
    }

    pub fn set_max_main_tokens_per_account<
        Arg0: ProxyArg<usize>,
    >(
        self,
        new_max_main_tokens_per_account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setMaxMainTokensPerAccount")
            .argument(&new_max_main_tokens_per_account)
            .original_result()
    }

    /// Creates a new stake pool with a Ashswap LP token. The Ashswap LP token must contain the USH token as one of the tokens in the LP. 
    ///  
    /// # Arguments: 
    ///  
    /// - `liquidity_pool` - Address of the Ashswap liquidity pool. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The token must not be already whitelisted. 
    /// - The token must be a valid token. 
    ///  
    pub fn create_ashswap_lp_stake_pool<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        liquidity_pool: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createAshswapLpStakePool")
            .argument(&liquidity_pool)
            .original_result()
    }

    /// Creates a new stake pool with a xExchange LP token. The xExchange LP token must contain the USH token as one of the tokens in the LP. 
    ///  
    /// # Arguments: 
    ///  
    /// - `liquidity_pool` - Address of the xExchange liquidity pool. 
    ///  
    /// # Notes: 
    ///  
    /// - Can only be called by the admin. 
    /// - The token must not be already whitelisted. 
    /// - The token must be a valid token. 
    ///  
    pub fn create_xex_lp_stake_pool<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        liquidity_pool: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createXexLpStakePool")
            .argument(&liquidity_pool)
            .original_result()
    }

    /// Removes an existing stake pool. 
    ///  
    /// The main token will be removed from the whitelisted stake tokens. The main token will be removed from the main stake tokens. 
    /// The pool ID will be removed from the stake token pool ID. The stake pool will be removed. 
    ///  
    /// # Arguments 
    ///  
    /// - `pool_id` - The stake pool ID. 
    ///  
    /// # Notes 
    ///  
    /// - The caller must be the admin. 
    /// - The stake pool must exist. 
    /// - The stake pool must not have any pool tokens. 
    /// - The total stake must be zero. 
    ///  
    pub fn remove_stake_pool<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pool_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeStakePool")
            .argument(&pool_id)
            .original_result()
    }

    /// Adds a new stake token to the stake pool. When a user stakes this token in the contract the balance of the stake pool will be increased. 
    ///  
    /// # Arguments 
    ///  
    /// - `stake_token` - The stake token to add to the pool token. 
    /// - `pool_id` - The stake pool ID. 
    ///  
    /// # Notes 
    ///  
    /// - The caller must be the admin. 
    /// - The stake pool must exist. 
    /// - The stake token must not be already whitelisted. 
    /// - The stake token must have a price provider with the main token. 
    ///  
    pub fn add_to_stake_pool<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        stake_token: Arg0,
        pool_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addToStakePool")
            .argument(&stake_token)
            .argument(&pool_id)
            .original_result()
    }

    /// Removes a stake token from the stake pool and ush staking. 
    ///  
    /// # Arguments 
    ///  
    /// - `stake_token` - The stake token to remove from the pool token. 
    ///  
    /// # Notes 
    ///  
    /// - The caller must be the admin. 
    /// - The stake pool must exist. 
    /// - The stake token must be added to the stake pool. 
    /// - The balance of the stake token must be zero. 
    /// - The stake for the stake token must be deactivated. 
    ///  
    pub fn remove_from_stake_pool<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        stake_token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeFromStakePool")
            .argument(&stake_token)
            .original_result()
    }

    /// Allows the account to stake a token. 
    ///  
    /// # Note 
    ///  
    /// - The token must be whitelisted. 
    /// - The account must be allowed to stake the token. 
    /// - The amount must be greater than zero. 
    /// - Staking could be allowed but this does not guarantee that the account will receive rewards. 
    ///  
    pub fn stake(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("stake")
            .original_result()
    }

    /// Allows the account to unstake a token. 
    ///  
    /// # Arguments 
    ///  
    /// - `payment` - An ESDT token payment describing the token identifier, nonce and amount to be unstaked. 
    ///  
    /// # Note 
    ///  
    /// - The token must be whitelisted. 
    /// - The account must have enough balance to unstake the amount. 
    /// - The amount must be greater than zero. 
    ///  
    pub fn unstake<
        Arg0: ProxyArg<EsdtTokenPayment<Env::Api>>,
    >(
        self,
        payment: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unstake")
            .argument(&payment)
            .original_result()
    }

    /// Stores the USH Minter smart contract address. 
    pub fn ush_minter(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshMinter")
            .original_result()
    }

    /// Stores the USH token identifier. 
    pub fn ush_token_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, TokenIdentifier<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUshTokenId")
            .original_result()
    }

    /// Stores the max number of main tokens that an account can have. 
    pub fn max_main_tokens_per_account(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getMaxMainTokensPerAccount")
            .original_result()
    }

    /// Stores the active state of staking for each stake token. 
    pub fn stake_active<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        token_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isStakeActive")
            .argument(&token_id)
            .original_result()
    }

    /// Stores the account's balance staked by token and nonce 
    pub fn account_token_balance_by_nonce<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<TokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        account: Arg0,
        stake_token: Arg1,
        nonce: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountTokenBalanceByNonce")
            .argument(&account)
            .argument(&stake_token)
            .argument(&nonce)
            .original_result()
    }

    /// Stores Rewards Booster smart contract address. 
    pub fn booster_observer(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedAddress<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBoosterObserver")
            .original_result()
    }

    /// Stores the stake token pool ID for each stake token. 
    pub fn stake_token_pool_id<
        Arg0: ProxyArg<TokenIdentifier<Env::Api>>,
    >(
        self,
        stake_token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakeTokenPoolId")
            .argument(&stake_token)
            .original_result()
    }

    /// Stores the stake pool information for the given pool ID. 
    pub fn stake_pool<
        Arg0: ProxyArg<usize>,
    >(
        self,
        pool_id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, StakePool<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getStakePool")
            .argument(&pool_id)
            .original_result()
    }

    /// Stores the total account's stake pool balance, considering all tokens in the pool. 
    pub fn account_stake_pool<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<usize>,
    >(
        self,
        account: Arg0,
        pool_id: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountStakePool")
            .argument(&account)
            .argument(&pool_id)
            .original_result()
    }

    /// Stores the last Stake Pool identifier. 
    pub fn last_pool_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, usize> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastPoolId")
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, PartialEq, Clone)]
pub struct StakePool<Api>
where
    Api: ManagedTypeApi,
{
    pub id: usize,
    pub main_token: TokenIdentifier<Api>,
    pub pool_tokens: ManagedVec<Api, TokenIdentifier<Api>>,
    pub total_stake: BigUint<Api>,
}
